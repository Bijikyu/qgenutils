/**
 * URL Utilities
 * Integrates qgenutils URL functions for comprehensive URL handling in email processing
 */

import {
  ensureProtocol,
  parseUrlParts
} from 'qgenutils';
import { validateString } from './validationUtils';

const normalizeUrlOrigin = (url) => {
  if (!url) return url;
  try {
    const parsed = new URL(url);
    return `${parsed.protocol}//${parsed.host}`;
  } catch {
    return url;
  }
};

const stripProtocol = (url) => {
  if (!url) return url;
  return url.replace(/^https?:\/\//, '');
};

/**
 * Processes and validates email links
 * @param {string} url - URL to process
 * @returns {Object} Processed URL with metadata
 */
const processEmailLink = (url) => {
  const validatedUrl = validateString(url, true);
  if (!validatedUrl) {
    return { isValid: false, url: '', error: 'URL must be a string' };
  }
  
  try {
    // Ensure proper protocol
    const secureUrl = ensureProtocol(url);
    
    // Parse URL components
    const { baseUrl, endpoint } = parseUrlParts(secureUrl);
    
    // Validate URL structure
    const urlObj = new URL(secureUrl);
    
    return {
      isValid: true,
      url: secureUrl,
      baseUrl,
      endpoint,
      domain: urlObj.hostname,
      protocol: urlObj.protocol,
      isSecure: urlObj.protocol === 'https:',
      isExternal: isExternalUrl(urlObj.hostname)
    };
  } catch (error) {
    return {
      isValid: false,
      url,
      error: `Invalid URL: ${error.message}`
    };
  }
};

/**
 * Checks if URL is external to current domain
 * @param {string} domain - Domain to check
 * @returns {boolean} True if external
 */
const isExternalUrl = (domain) => {
  if (!domain) return true;
  
  // List of common email service domains considered safe
  const safeDomains = [
    'gmail.com',
    'google.com',
    'outlook.com',
    'protonmail.com',
    'proton.me',
    'yahoo.com',
    'hotmail.com',
    'icloud.com'
  ];
  
  return !safeDomains.includes(domain.toLowerCase());
};

/**
 * Sanitizes URL for display
 * @param {string} url - URL to sanitize
 * @returns {string} Sanitized URL safe for display
 */
const sanitizeUrlForDisplay = (url) => {
  const validatedUrl = validateString(url, true);
  if (!validatedUrl) {
    return '';
  }
  
  try {
    // Remove tracking parameters
    const urlObj = new URL(url);
    const params = new URLSearchParams(urlObj.search);
    
    // Common tracking parameters to remove
    const trackingParams = [
      'utm_source', 'utm_medium', 'utm_campaign', 'utm_term', 'utm_content',
      'fbclid', 'gclid', 'msclkid', 'igshid', 'si', 'source', 'ref'
    ];
    
    trackingParams.forEach(param => params.delete(param));
    
    // Rebuild URL without tracking
    urlObj.search = params.toString();
    const cleanUrl = urlObj.toString();
    
    // Normalize for display
    return stripProtocol(cleanUrl);
  } catch (error) {
    // Fallback to basic sanitization
    return url.replace(/[<>'"\\]/g, '').substring(0, 200);
  }
};

/**
 * Extracts URLs from email content
 * @param {string} content - Email content to parse
 * @returns {Array} Array of found URLs
 */
const extractUrlsFromContent = (content) => {
  const validatedContent = validateString(content, true);
  if (!validatedContent) {
    return [];
  }
  
  // URL regex pattern
  const urlRegex = /(https?:\/\/[^\s<>'"\\)]+)/gi;
  const matches = content.match(urlRegex) || [];
  
  // Process and deduplicate URLs
  const processedUrls = matches.map(url => processEmailLink(url.trim()))
    .filter(result => result.isValid)
    .filter((result, index, arr) => 
      arr.findIndex(item => item.url === result.url) === index
    );
  
  return processedUrls;
};

/**
 * Creates safe redirect URL
 * @param {string} url - Target URL
 * @param {string} baseUrl - Base URL for redirect
 * @returns {string} Safe redirect URL
 */
const createSafeRedirect = (url, baseUrl = null) => {
  const defaultBase = typeof window !== 'undefined' ? window.location.origin : 'http://localhost:3000';
  const finalBase = baseUrl || defaultBase;
  const processed = processEmailLink(url);
  
  if (!processed.isValid) {
    return `${finalBase}/unsafe-url`;
  }
  
  // For external URLs, show warning page
  if (processed.isExternal) {
    return `${finalBase}/redirect?url=${encodeURIComponent(processed.url)}`;
  }
  
  return processed.url;
};

/**
 * Validates email unsubscribe links
 * @param {string} url - Unsubscribe URL to validate
 * @returns {Object} Validation result
 */
const validateUnsubscribeLink = (url) => {
  const validatedUrl = validateString(url, true);
  if (!validatedUrl) {
    return { isValid: false, reason: 'URL must be a string' };
  }
  
  const processed = processEmailLink(url);
  if (!processed.isValid) {
    return { isValid: false, reason: processed.error };
  }
  
  // Check for common unsubscribe patterns
  const unsubscribePatterns = [
    /unsubscribe/i,
    /opt.?out/i,
    /remove/i,
    /list.?unsubscribe/i,
    /mail.?to/i
  ];
  
  const hasUnsubscribePattern = unsubscribePatterns.some(pattern => 
    pattern.test(url) || pattern.test(processed.endpoint)
  );
  
  return {
    isValid: true,
    url: processed.url,
    isUnsubscribeLink: hasUnsubscribePattern,
    trustLevel: hasUnsubscribePattern ? 'high' : 'medium'
  };
};

/**
 * Normalizes URL for comparison
 * @param {string} url - URL to normalize
 * @returns {string} Normalized URL
 */
const normalizeUrl = (url) => {
  const validatedUrl = validateString(url, true);
  if (!validatedUrl) {
    return '';
  }
  
  try {
    const processed = processEmailLink(url);
    if (!processed.isValid) {
      return url;
    }
    
    return normalizeUrlOrigin(processed.url);
  } catch (error) {
    return url;
  }
};

/**
 * Gets domain from URL
 * @param {string} url - URL to extract domain from
 * @returns {string} Domain name or empty string
 */
const getDomainFromUrl = (url) => {
  if (!url || typeof url !== 'string') return '';
  try {
    const processed = processEmailLink(url);
    return processed.isValid ? processed.domain : '';
  } catch (error) {
    return '';
  }
};

/**
 * Checks if URL uses HTTPS
 * @param {string} url - URL to check
 * @returns {boolean} True if HTTPS
 */
const isSecureUrl = (url) => {
  const processed = processEmailLink(url);
  return processed.isValid ? processed.isSecure : false;
};

/**
 * Creates URL preview metadata
 * @param {string} url - URL to preview
 * @returns {Object} Preview metadata
 */
const createUrlPreview = (url) => {
  const processed = processEmailLink(url);
  
  if (!processed.isValid) {
    return {
      title: 'Invalid URL',
      description: processed.error,
      favicon: '',
      domain: '',
      isSecure: false
    };
  }
  
  return {
    title: processed.domain,
    description: `${processed.isExternal ? 'External' : 'Internal'} link`,
    favicon: `https://www.google.com/s2/favicons?domain=${processed.domain}`,
    domain: processed.domain,
    isSecure: processed.isSecure,
    isExternal: processed.isExternal
  };
};

module.exports = {
  // Re-export qgenutils URL functions
  ensureProtocol,
  normalizeUrlOrigin,
  stripProtocol,
  parseUrlParts,
  
  // Application-specific URL functions
  processEmailLink,
  sanitizeUrlForDisplay,
  extractUrlsFromContent,
  createSafeRedirect,
  validateUnsubscribeLink,
  normalizeUrl,
  getDomainFromUrl,
  isSecureUrl,
  createUrlPreview,
  isExternalUrl
};