@qutils/logger-bridge
Purpose: Provides unified logger access with fallback to console methods.

Explanation:
This utility offers a consistent interface for application logging, bridging between the qgenutils logger and console methods as fallback. It solves the problem of inconsistent logging across different environments and dependencies by providing a single, reliable logger interface that works regardless of whether qgenutils is available. The module is broadly applicable to any Node.js application that needs structured logging, particularly libraries and utilities that should not depend on specific logging implementations. It provides methods for info, warn, error, and debug logging, with automatic fallback to console methods when the preferred logger is unavailable.

/**
 * @file loggerBridge.ts
 * @description Bridges to shared logger core; preserves existing public API for utils consumers.
 */
import type { AppLogger } from './getAppLoggerCore.js';
import { getAppLoggerCore } from './getAppLoggerCore.js';
import { createRunIdCore } from './createRunIdCore.js';
/**
 * Retrieves the shared logger exposed by qgenutils, falling back to console methods when unavailable.
 * @returns AppLogger Ensures callers always have a logger supporting info/warn/error/debug.
 */
export const getAppLogger = (): AppLogger => getAppLoggerCore();
/**
 * Generates a structured execution identifier that combines the provided prefix with qgenutils' generator.
 * @param prefix Human-readable prefix describing the operation being logged.
 * @returns string Stable run identifier useful for log correlation across async boundaries.
 */
export const createRunId = (prefix: string): string => createRunIdCore(prefix);

@qutils/task-scheduler
Purpose: Centralized task scheduling to reduce resource contention from multiple timers.

Explanation:
This utility provides a centralized task scheduler that consolidates multiple setInterval instances into a single efficient timer system. It solves the performance problem of resource contention caused by numerous independent timers by using a single tick loop that manages all scheduled tasks. The module is broadly applicable to any Node.js application with multiple recurring tasks, particularly background job processors, cleanup routines, and monitoring systems. It provides task registration, enable/disable controls, performance statistics, and graceful shutdown capabilities while maintaining precise timing and reducing CPU overhead.

/**
 * @file scheduler.ts
 * @description Centralized task scheduler to consolidate multiple setInterval instances and reduce CPU contention
 * 
 * Rationale:
 * - Multiple setInterval instances across files cause resource contention
 * - Centralized scheduling allows for better resource management
 * - Provides unified timing and cleanup mechanisms
 */
export interface ScheduledTask {
  id: string;
  fn: () => void | Promise<void>;
  interval: number;
  lastRun: number;
  enabled: boolean;
}
export class TaskScheduler {
  private static instance: TaskScheduler;
  private tasks = new Map<string, ScheduledTask>();
  private timer: NodeJS.Timeout | null = null;
  private readonly tickInterval = 1000; // 1 second tick for precision
  private constructor() {}
  public static getInstance(): TaskScheduler {
    if (!TaskScheduler.instance) {
      TaskScheduler.instance = new TaskScheduler();
    }
    return TaskScheduler.instance;
  }
  /**
   * Schedule a recurring task
   */
  public schedule(id: string, fn: () => void | Promise<void>, interval: number): void {
    // Remove existing task if present
    this.unschedule(id);
    const task: ScheduledTask = {
      id,
      fn,
      interval,
      lastRun: 0,
      enabled: true
    };
    this.tasks.set(id, task);
    
    // Start timer if not already running
    this.startTimer();
  }
  /**
   * Remove a scheduled task
   */
  public unschedule(id: string): void {
    this.tasks.delete(id);
    
    // Stop timer if no tasks remaining
    if (this.tasks.size === 0 && this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }
  }
  /**
   * Enable/disable a task without removing it
   */
  public setTaskEnabled(id: string, enabled: boolean): void {
    const task = this.tasks.get(id);
    if (task) {
      task.enabled = enabled;
    }
  }
  /**
   * Get task status
   */
  public getTask(id: string): ScheduledTask | undefined {
    return this.tasks.get(id);
  }
  /**
   * Get all active tasks
   */
  public getAllTasks(): ScheduledTask[] {
    return Array.from(this.tasks.values());
  }
  /**
   * Shutdown all tasks and cleanup
   */
  public shutdown(): void {
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }
    this.tasks.clear();
  }
  /**
   * Start the main timer if not already running
   */
  private startTimer(): void {
    if (this.timer) return;
    this.timer = setInterval(() => {
      this.tick();
    }, this.tickInterval);
  }
  /**
   * Main tick loop - checks and runs due tasks
   */
  private async tick(): Promise<void> {
    const now = Date.now();
    
    for (const task of this.tasks.values()) {
      if (!task.enabled) continue;
      
      const timeSinceLastRun = now - task.lastRun;
      if (timeSinceLastRun >= task.interval) {
        try {
          await Promise.resolve(task.fn());
          task.lastRun = now;
        } catch (error) {
          console.error(`Task ${task.id} failed:`, error);
          // Continue with other tasks even if one fails
        }
      }
    }
  }
  /**
   * Get performance statistics
   */
  public getStats(): {
    totalTasks: number;
    enabledTasks: number;
    averageInterval: number;
  } {
    const tasks = Array.from(this.tasks.values());
    const enabledTasks = tasks.filter(t => t.enabled);
    const averageInterval = tasks.length > 0 
      ? tasks.reduce((sum, t) => sum + t.interval, 0) / tasks.length 
      : 0;
    return {
      totalTasks: tasks.length,
      enabledTasks: enabledTasks.length,
      averageInterval
    };
  }
}
// Export singleton instance
export const scheduler = TaskScheduler.getInstance();

@qutils/endpoint-meta
Purpose: Constructs consistent API endpoint metadata for documentation and introspection.

Explanation:
This utility provides a standardized way to build and attach metadata to API endpoints, enabling consistent documentation, introspection, and API discovery. It solves the problem of inconsistent endpoint documentation by providing a structured approach to defining route information, HTTP methods, descriptions, authentication requirements, and schema definitions. The module is broadly applicable to any Node.js API framework that needs structured endpoint metadata, particularly REST APIs, GraphQL resolvers, and API documentation systems. It provides builders for endpoint metadata and decorators for attaching metadata to functions, supporting comprehensive API documentation and discovery features.

/**
 * @file endpointMeta.ts
 * @description Utility to construct EndpointMeta objects consistently across controllers.
 * Centralizes repeated route/method/description/role/apiKey/schema/exampleInput scaffolding.
 */
export interface BuildEndpointMetaOptions{route?:string;method?:'get'|'post'|'put'|'patch'|'delete';description?:string;requiredRole?:string;apiKeyRequired?:boolean;schema?:any;exampleInput?:unknown;collection?:string;jsonSchema?:unknown;plan?:'free'|'pro'|'custom';}
export interface EndpointMeta extends BuildEndpointMetaOptions {}
export interface MetaAwareFn<T extends(...args:any[])=>unknown> {
  (...args: Parameters<T>): ReturnType<T>;
  meta?: EndpointMeta;
}
export const buildEndpointMeta=(opts:BuildEndpointMetaOptions):EndpointMeta=>({
	route:opts.route,method:opts.method,description:opts.description,requiredRole:opts.requiredRole,
	apiKeyRequired:opts.apiKeyRequired,schema:opts.schema,exampleInput:opts.exampleInput,
	collection:opts.collection,jsonSchema:opts.jsonSchema,plan:opts.plan
});
export const attachEndpointMeta=<T extends(...args:any[])=>unknown>(fn:T,opts:BuildEndpointMetaOptions):void=>{(fn as MetaAwareFn<T>).meta=buildEndpointMeta(opts);};
export default buildEndpointMeta;