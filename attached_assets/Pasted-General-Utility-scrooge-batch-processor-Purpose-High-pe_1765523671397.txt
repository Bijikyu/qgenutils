General Utility
@scrooge/batch-processor
Purpose: High-performance batch processing utilities with configurable concurrency, error handling, and progress tracking. Explanation:
This module provides comprehensive batch processing capabilities that handle large datasets efficiently with configurable concurrency limits, retry mechanisms, and detailed progress tracking. It solves the problem of processing large datasets without overwhelming system resources or losing track of failed items. This would be reused across any application that needs to process large amounts of data, particularly in data migration, bulk operations, and background processing tasks.

The module accepts arrays of items, processing functions, and configuration options, returning detailed results with success/failure tracking, retry information, and progress updates. It handles edge cases like memory limitations, partial failures, and provides comprehensive error reporting.

/**
 * Batch Processor Utilities
 * High-performance batch processing with concurrency control and error handling
 */
export interface BatchProcessorOptions {
  concurrency?: number;
  retries?: number;
  retryDelay?: number;
  batchSize?: number;
  progressCallback?: (progress: BatchProgress) => void;
  errorCallback?: (error: Error, item: any, index: number) => void;
  filterSuccessful?: boolean;
  stopOnError?: boolean;
  timeout?: number;
}
export interface BatchProgress {
  total: number;
  processed: number;
  successful: number;
  failed: number;
  percentage: number;
  startTime: number;
  eta?: number;
}
export interface BatchResult<T> {
  successful: Array<{ item: any; result: T; index: number }>;
  failed: Array<{ item: any; error: Error; index: number; retries: number }>;
  total: number;
  successCount: number;
  failureCount: number;
  duration: number;
  throughput: number;
}
export class BatchProcessor<T = any> {
  private defaultOptions: Required<BatchProcessorOptions> = {
    concurrency: 10,
    retries: 3,
    retryDelay: 1000,
    batchSize: 100,
    progressCallback: () => {},
    errorCallback: () => {},
    filterSuccessful: false,
    stopOnError: false,
    timeout: 30000
  };
  constructor(options: BatchProcessorOptions = {}) {
    this.defaultOptions = { ...this.defaultOptions, ...options };
  }
  /**
   * Process items in batches with concurrency control
   */
  public async process(
    items: any[],
    processor: (item: any, index: number) => Promise<T>,
    options: BatchProcessorOptions = {}
  ): Promise<BatchResult<T>> {
    const config = { ...this.defaultOptions, ...options };
    const startTime = Date.now();
    
    const result: BatchResult<T> = {
      successful: [],
      failed: [],
      total: items.length,
      successCount: 0,
      failureCount: 0,
      duration: 0,
      throughput: 0
    };
    const progress: BatchProgress = {
      total: items.length,
      processed: 0,
      successful: 0,
      failed: 0,
      percentage: 0,
      startTime
    };
    // Process in batches
    for (let i = 0; i < items.length; i += config.batchSize) {
      const batch = items.slice(i, i + config.batchSize);
      
      if (config.stopOnError && result.failureCount > 0) {
        break;
      }
      // Process batch with concurrency control
      const batchResults = await this.processBatch(
        batch,
        processor,
        i,
        config,
        progress
      );
      // Accumulate results
      result.successful.push(...batchResults.successful);
      result.failed.push(...batchResults.failed);
      result.successCount += batchResults.successCount;
      result.failureCount += batchResults.failureCount;
      // Update progress
      progress.processed += batch.length;
      progress.successful = result.successCount;
      progress.failed = result.failureCount;
      progress.percentage = (progress.processed / progress.total) * 100;
      
      if (progress.processed > 0) {
        const elapsed = Date.now() - startTime;
        const rate = progress.processed / elapsed;
        const remaining = progress.total - progress.processed;
        progress.eta = remaining / rate;
      }
      config.progressCallback(progress);
    }
    // Calculate final metrics
    result.duration = Date.now() - startTime;
    result.throughput = result.processed / (result.duration / 1000);
    return result;
  }
  /**
   * Process a single batch with concurrency control
   */
  private async processBatch(
    batch: any[],
    processor: (item: any, index: number) => Promise<T>,
    startIndex: number,
    config: Required<BatchProcessorOptions>,
    progress: BatchProgress
  ): Promise<{
    successful: Array<{ item: any; result: T; index: number }>;
    failed: Array<{ item: any; error: Error; index: number; retries: number }>;
    successCount: number;
    failureCount: number;
  }> {
    const semaphore = new Semaphore(config.concurrency);
    
    const promises = batch.map(async (item, batchIndex) => {
      const globalIndex = startIndex + batchIndex;
      
      return semaphore.acquire().then(async (release) => {
        try {
          // Execute with timeout
          const result = await Promise.race([
            processor(item, globalIndex),
            new Promise<never>((_, reject) => 
              setTimeout(() => reject(new Error('Timeout')), config.timeout)
            )
          ]);
          return {
            success: true,
            item,
            result,
            index: globalIndex,
            retries: 0
          };
        } catch (error) {
          // Retry logic
          const retryResult = await this.retryItem(
            item,
            processor,
            globalIndex,
            error as Error,
            config
          );
          if (retryResult.success) {
            return retryResult;
          } else {
            config.errorCallback(retryResult.error, item, globalIndex);
            return retryResult;
          }
        } finally {
          release();
        }
      });
    });
    const results = await Promise.allSettled(promises);
    
    // Separate successful and failed results
    const successful: Array<{ item: any; result: T; index: number }> = [];
    const failed: Array<{ item: any; error: Error; index: number; retries: number }> = [];
    results.forEach((result, index) => {
      if (result.status === 'fulfilled') {
        const itemResult = result.value;
        if (itemResult.success) {
          successful.push({
            item: itemResult.item,
            result: itemResult.result,
            index: itemResult.index
          });
        } else {
          failed.push({
            item: itemResult.item,
            error: itemResult.error,
            index: itemResult.index,
            retries: itemResult.retries
          });
        }
      } else {
        failed.push({
          item: batch[index],
          error: result.reason as Error,
          index: startIndex + index,
          retries: 0
        });
      }
    });
    return {
      successful,
      failed,
      successCount: successful.length,
      failureCount: failed.length
    };
  }
  /**
   * Retry a failed item with exponential backoff
   */
  private async retryItem(
    item: any,
    processor: (item: any, index: number) => Promise<T>,
    index: number,
    initialError: Error,
    config: Required<BatchProcessorOptions>
  ): Promise<{
    success: boolean;
    item: any;
    result?: T;
    error: Error;
    index: number;
    retries: number;
  }> {
    let lastError = initialError;
    let retries = 0;
    
    for (let attempt = 1; attempt <= config.retries; attempt++) {
      // Exponential backoff
      const delay = config.retryDelay * Math.pow(2, attempt - 1);
      await new Promise(resolve => setTimeout(resolve, delay));
      
      try {
        const result = await Promise.race([
          processor(item, index),
          new Promise<never>((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), config.timeout)
          )
        ]);
        return {
          success: true,
          item,
          result,
          error: lastError,
          index,
          retries: attempt
        };
      } catch (error) {
        lastError = error as Error;
        retries = attempt;
      }
    }
    return {
      success: false,
      item,
      error: lastError,
      index,
      retries
    };
  }
  /**
   * Process items with memory-efficient streaming
   */
  public async processStream(
    items: AsyncIterable<any>,
    processor: (item: any, index: number) => Promise<T>,
    options: BatchProcessorOptions = {}
  ): Promise<BatchResult<T>> {
    const config = { ...this.defaultOptions, ...options };
    const startTime = Date.now();
    
    const result: BatchResult<T> = {
      successful: [],
      failed: [],
      total: 0,
      successCount: 0,
      failureCount: 0,
      duration: 0,
      throughput: 0
    };
    const progress: BatchProgress = {
      total: 0,
      processed: 0,
      successful: 0,
      failed: 0,
      percentage: 0,
      startTime
    };
    let index = 0;
    const semaphore = new Semaphore(config.concurrency);
    for await (const item of items) {
      result.total++;
      progress.total++;
      if (config.stopOnError && result.failureCount > 0) {
        break;
      }
      semaphore.acquire().then(release => {
        processor(item, index++)
          .then(resultData => {
            result.successful.push({ item, result: resultData, index: index - 1 });
            result.successCount++;
            progress.successful++;
            
            this.updateProgress(progress, result.total, result.successCount, result.failureCount);
            config.progressCallback(progress);
            release();
          })
          .catch(error => {
            result.failed.push({ item, error: error as Error, index: index - 1, retries: 0 });
            result.failureCount++;
            progress.failed++;
            
            config.errorCallback(error as Error, item, index - 1);
            this.updateProgress(progress, result.total, result.successCount, result.failureCount);
            config.progressCallback(progress);
            release();
          });
      });
    }
    // Wait for all processing to complete
    await semaphore.waitForAll();
    // Calculate final metrics
    result.duration = Date.now() - startTime;
    result.throughput = result.processed / (result.duration / 1000);
    return result;
  }
  /**
   * Update progress and calculate ETA
   */
  private updateProgress(
    progress: BatchProgress,
    total: number,
    successful: number,
    failed: number
  ): void {
    progress.processed = successful + failed;
    progress.successful = successful;
    progress.failed = failed;
    progress.percentage = total > 0 ? (progress.processed / total) * 100 : 0;
    
    if (progress.processed > 0) {
      const elapsed = Date.now() - progress.startTime;
      const rate = progress.processed / elapsed;
      const remaining = total - progress.processed;
      progress.eta = remaining / rate;
    }
  }
}
/**
 * Simple semaphore for concurrency control
 */
class Semaphore {
  private permits: number;
  private waitQueue: Array<(permit: () => void) => void> = [];
  constructor(permits: number) {
    this.permits = permits;
  }
  public async acquire(): Promise<() => void> {
    return new Promise(resolve => {
      if (this.permits > 0) {
        this.permits--;
        resolve(() => this.release());
      } else {
        this.waitQueue.push(resolve);
      }
    });
  }
  public release(): void {
    if (this.waitQueue.length > 0) {
      const resolve = this.waitQueue.shift()!;
      resolve(() => this.release());
    } else {
      this.permits++;
    }
  }
  public async waitForAll(): Promise<void> {
    while (this.permits < 10 || this.waitQueue.length > 0) {
      await new Promise(resolve => setTimeout(resolve, 10));
    }
  }
}
// Factory functions for common use cases
export const createBatchProcessor = <T = any>(options: BatchProcessorOptions = {}) => 
  new BatchProcessor<T>(options);
export const createConcurrentProcessor = <T = any>(concurrency: number, options: BatchProcessorOptions = {}) =>
  new BatchProcessor<T>({ ...options, concurrency });
export const createRetryProcessor = <T = any>(retries: number, options: BatchProcessorOptions = {}) =>
  new BatchProcessor<T>({ ...options, retries });
export default BatchProcessor;

@scrooge/collection-utils
Purpose: Comprehensive collection manipulation utilities with functional programming patterns and performance optimizations. Explanation:
This module provides a suite of utility functions for working with arrays and objects using functional programming patterns. It solves the problem of common collection manipulation tasks that are repetitive or error-prone when implemented manually. This would be reused across any JavaScript/TypeScript application that works with data structures, particularly in data processing, transformation pipelines, and API response handling.

The module accepts arrays, objects, and transformation functions, providing consistent interfaces for common operations like grouping, partitioning, deduplication, and advanced filtering. It handles edge cases like null/undefined inputs, empty collections, and provides immutable operations.

/**
 * Collection Utilities
 * Functional programming utilities for arrays and objects
 */
// Array utilities
/**
 * Group array elements by a key function
 */
export const groupBy = <T, K extends string | number>(
  array: T[],
  keyFn: (item: T) => K
): Record<K, T[]> => {
  return array.reduce((groups, item) => {
    const key = keyFn(item);
    if (!groups[key]) {
      groups[key] = [];
    }
    groups[key].push(item);
    return groups;
  }, {} as Record<K, T[]>);
};
/**
 * Partition array into two arrays based on predicate
 */
export const partition = <T>(
  array: T[],
  predicate: (item: T) => boolean
): [T[], T[]] => {
  return array.reduce(
    ([pass, fail], item) => 
      predicate(item) ? [[...pass, item], fail] : [pass, [...fail, item]],
    [[], []] as [T[], T[]]
  );
};
/**
 * Unique array elements using optional key function
 */
export const unique = <T>(
  array: T[],
  keyFn?: (item: T) => any
): T[] => {
  if (!keyFn) {
    return [...new Set(array)];
  }
  const seen = new Set();
  return array.filter(item => {
    const key = keyFn(item);
    if (seen.has(key)) {
      return false;
    }
    seen.add(key);
    return true;
  });
};
/**
 * Chunk array into smaller arrays of specified size
 */
export const chunk = <T>(array: T[], size: number): T[][] => {
  if (size <= 0) {
    throw new Error('Chunk size must be greater than 0');
  }
  const chunks: T[][] = [];
  for (let i = 0; i < array.length; i += size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
};
/**
 * Flatten nested arrays
 */
export const flatten = <T>(array: (T | T[])[]): T[] => {
  return array.reduce((flat, item) => 
    flat.concat(Array.isArray(item) ? flatten(item) : item), 
    [] as T[]
  );
};
/**
 * Find intersection of multiple arrays
 */
export const intersection = <T>(...arrays: T[][]): T[] => {
  if (arrays.length === 0) return [];
  if (arrays.length === 1) return arrays[0];
  const [first, ...rest] = arrays;
  return first.filter(item => 
    rest.every(array => array.includes(item))
  );
};
/**
 * Find difference between arrays (items in first array not in others)
 */
export const difference = <T>(array: T[], ...excludeArrays: T[][]): T[] => {
  const excludeSet = new Set(excludeArrays.flat());
  return array.filter(item => !excludeSet.has(item));
};
/**
 * Sort array by multiple criteria
 */
export const sortBy = <T>(
  array: T[],
  ...criteria: Array<(item: T) => any>
): T[] => {
  return [...array].sort((a, b) => {
    for (const criterion of criteria) {
      const aVal = criterion(a);
      const bVal = criterion(b);
      
      if (aVal < bVal) return -1;
      if (aVal > bVal) return 1;
    }
    return 0;
  });
};
/**
 * Randomly shuffle array (Fisher-Yates algorithm)
 */
export const shuffle = <T>(array: T[]): T[] => {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
};
/**
 * Take first n elements from array
 */
export const take = <T>(array: T[], n: number): T[] => {
  return array.slice(0, Math.max(0, n));
};
/**
 * Take elements from array while predicate is true
 */
export const takeWhile = <T>(
  array: T[],
  predicate: (item: T, index: number) => boolean
): T[] => {
  const result: T[] = [];
  for (let i = 0; i < array.length; i++) {
    const item = array[i];
    if (predicate(item, i)) {
      result.push(item);
    } else {
      break;
    }
  }
  return result;
};
/**
 * Skip first n elements from array
 */
export const skip = <T>(array: T[], n: number): T[] => {
  return array.slice(Math.max(0, n));
};
/**
 * Skip elements while predicate is true
 */
export const skipWhile = <T>(
  array: T[],
  predicate: (item: T, index: number) => boolean
): T[] => {
  let skipIndex = 0;
  for (let i = 0; i < array.length; i++) {
    if (predicate(array[i], i)) {
      skipIndex = i + 1;
    } else {
      break;
    }
  }
  return array.slice(skipIndex);
};
// Object utilities
/**
 * Pick specific keys from object
 */
export const pick = <T extends Record<string, any>, K extends keyof T>(
  obj: T,
  keys: K[]
): Pick<T, K> => {
  const result = {} as Pick<T, K>;
  keys.forEach(key => {
    if (key in obj) {
      result[key] = obj[key];
    }
  });
  return result;
};
/**
 * Omit specific keys from object
 */
export const omit = <T extends Record<string, any>, K extends keyof T>(
  obj: T,
  keys: K[]
): Omit<T, K> => {
  const result = { ...obj };
  keys.forEach(key => {
    delete result[key];
  });
  return result as Omit<T, K>;
};
/**
 * Deep merge objects
 */
export const deepMerge = <T extends Record<string, any>>(...objects: Partial<T>[]): T => {
  return objects.reduce((result, obj) => {
    Object.keys(obj).forEach(key => {
      const value = obj[key as keyof T];
      const existingValue = result[key as keyof T];
      if (isPlainObject(value) && isPlainObject(existingValue)) {
        result[key as keyof T] = deepMerge(existingValue, value) as T[keyof T];
      } else {
        result[key as keyof T] = value as T[keyof T];
      }
    });
    return result;
  }, {} as T);
};
/**
 * Check if value is a plain object
 */
export const isPlainObject = (value: any): value is Record<string, any> => {
  return (
    typeof value === 'object' &&
    value !== null &&
    !Array.isArray(value) &&
    !(value instanceof Date) &&
    !(value instanceof RegExp) &&
    !(value instanceof Map) &&
    !(value instanceof Set)
  );
};
/**
 * Deep clone object
 */
export const deepClone = <T>(obj: T): T => {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  if (obj instanceof Date) {
    return new Date(obj.getTime()) as T;
  }
  if (obj instanceof Array) {
    return obj.map(item => deepClone(item)) as T;
  }
  if (isPlainObject(obj)) {
    const cloned = {} as T;
    Object.keys(obj).forEach(key => {
      cloned[key as keyof T] = deepClone(obj[key as keyof T]);
    });
    return cloned;
  }
  return obj;
};
/**
 * Get nested value from object with default
 */
export const get = <T = any>(
  obj: Record<string, any>,
  path: string,
  defaultValue: T
): T => {
  const keys = path.split('.');
  let current = obj;
  for (const key of keys) {
    if (current === null || current === undefined || !(key in current)) {
      return defaultValue;
    }
    current = current[key];
  }
  return current !== undefined ? current : defaultValue;
};
/**
 * Set nested value in object
 */
export const set = (obj: Record<string, any>, path: string, value: any): void => {
  const keys = path.split('.');
  const lastKey = keys.pop()!;
  let current = obj;
  for (const key of keys) {
    if (!(key in current) || !isPlainObject(current[key])) {
      current[key] = {};
    }
    current = current[key];
  }
  current[lastKey] = value;
};
/**
 * Check if objects are deeply equal
 */
export const isEqual = (a: any, b: any): boolean => {
  if (a === b) return true;
  if (a === null || b === null) return a === b;
  if (typeof a !== typeof b) return false;
  if (typeof a !== 'object') return a === b;
  if (Array.isArray(a) !== Array.isArray(b)) return false;
  if (Array.isArray(a)) {
    if (a.length !== b.length) return false;
    return a.every((item, index) => isEqual(item, b[index]));
  }
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length) return false;
  return keysA.every(key => 
    keysB.includes(key) && isEqual(a[key], b[key])
  );
};
/**
 * Transform object keys using mapping function
 */
export const mapKeys = <T extends Record<string, any>, U extends Record<string, any>>(
  obj: T,
  keyMapper: (key: keyof T, value: T[keyof T]) => string
): U => {
  const result = {} as U;
  Object.keys(obj).forEach(key => {
    const typedKey = key as keyof T;
    const newKey = keyMapper(typedKey, obj[typedKey]);
    result[newKey as keyof U] = obj[typedKey];
  });
  return result;
};
/**
 * Transform object values using mapping function
 */
export const mapValues = <T extends Record<string, any>, U extends Record<string, any>>(
  obj: T,
  valueMapper: (value: T[keyof T], key: keyof T) => any
): U => {
  const result = {} as U;
  Object.keys(obj).forEach(key => {
    const typedKey = key as keyof T;
    result[typedKey as keyof U] = valueMapper(obj[typedKey], typedKey);
  });
  return result;
};
/**
 * Filter object keys based on predicate
 */
export const filterKeys = <T extends Record<string, any>, U extends Record<string, any>>(
  obj: T,
  predicate: (key: keyof T, value: T[keyof T]) => boolean
): U => {
  const result = {} as U;
  Object.keys(obj).forEach(key => {
    const typedKey = key as keyof T;
    if (predicate(typedKey, obj[typedKey])) {
      result[typedKey as keyof U] = obj[typedKey];
    }
  });
  return result;
};
/**
 * Check if object is empty
 */
export const isEmpty = (obj: any): boolean => {
  if (obj == null) return true;
  if (Array.isArray(obj)) return obj.length === 0;
  if (typeof obj === 'object') return Object.keys(obj).length === 0;
  return false;
};
/**
 * Convert object to query string
 */
export const toQueryString = (obj: Record<string, any>): string => {
  const params = new URLSearchParams();
  
  Object.entries(obj).forEach(([key, value]) => {
    if (value !== null && value !== undefined) {
      params.append(key, String(value));
    }
  });
  
  return params.toString();
};
/**
 * Convert query string to object
 */
export const fromQueryString = (queryString: string): Record<string, string> => {
  const params = new URLSearchParams(queryString);
  const result: Record<string, string> = {};
  
  params.forEach((value, key) => {
    result[key] = value;
  });
  
  return result;
};
// Performance utilities
/**
 * Memoize function with LRU cache
 */
export const memoize = <T extends (...args: any[]) => any>(
  fn: T,
  maxSize?: number
): T => {
  const cache = new Map<string, ReturnType<T>>();
  
  return ((...args: any[]) => {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      const value = cache.get(key)!;
      // Move to end (LRU)
      cache.delete(key);
      cache.set(key, value);
      return value;
    }
    
    const result = fn(...args);
    
    // Manage cache size
    if (maxSize && cache.size >= maxSize) {
      const firstKey = cache.keys().next().value;
      cache.delete(firstKey);
    }
    
    cache.set(key, result);
    return result;
  }) as T;
};
/**
 * Throttle function execution
 */
export const throttle = <T extends (...args: any[]) => any>(
  fn: T,
  delay: number
): T => {
  let lastCall = 0;
  let timeoutId: NodeJS.Timeout | null = null;
  
  return ((...args: any[]) => {
    const now = Date.now();
    
    if (now - lastCall >= delay) {
      lastCall = now;
      return fn(...args);
    }
    
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    
    timeoutId = setTimeout(() => {
      lastCall = Date.now();
      return fn(...args);
    }, delay - (now - lastCall));
  }) as T;
};
/**
 * Debounce function execution
 */
export const debounce = <T extends (...args: any[]) => any>(
  fn: T,
  delay: number
): T => {
  let timeoutId: NodeJS.Timeout | null = null;
  
  return ((...args: any[]) => {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    
    timeoutId = setTimeout(() => {
      fn(...args);
    }, delay);
  }) as T;
};
// Default export with all utilities
export default {
  // Array utilities
  groupBy,
  partition,
  unique,
  chunk,
  flatten,
  intersection,
  difference,
  sortBy,
  shuffle,
  take,
  takeWhile,
  skip,
  skipWhile,
  
  // Object utilities
  pick,
  omit,
  deepMerge,
  deepClone,
  get,
  set,
  isEqual,
  mapKeys,
  mapValues,
  filterKeys,
  isEmpty,
  toQueryString,
  fromQueryString,
  
  // Performance utilities
  memoize,
  throttle,
  debounce
};