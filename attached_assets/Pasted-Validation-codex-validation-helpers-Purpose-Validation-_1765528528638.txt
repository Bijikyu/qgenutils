Validation
@codex/validation-helpers
Purpose: Validation error helper utilities for server controllers with standardized error handling. Explanation:
This module provides comprehensive validation helpers for Express controllers, offering standardized validation error handling with optional library integration. It solves the problem of inconsistent validation error responses by providing factory functions for creating validation error handlers and common validation functions for different data types. The module integrates with optional error handling libraries while providing fallbacks for basic Express applications.

The module is essential for maintaining consistent API validation responses, reducing boilerplate code in controllers, and ensuring proper error formatting across different validation scenarios.

/**
 * Validation error helper utilities for server controllers.
 *
 * Eliminates duplication across controllers by providing standardized
 * validation error handling with optional qerrors integration.
 */
import type { Request, Response } from 'express';
import { loadQerrors } from './qerrorsLoader';
import { sendValidationError } from './responseHelpers';
/**
 * Creates a validation error handler for a specific controller.
 *
 * @param controllerName - Name of the controller for error context
 * @returns Function that handles validation errors with consistent formatting
 */
export function createValidationErrorHandler(controllerName: string) {
  return async function handleValidationError(
    res: Response,
    message: string,
    fieldName?: string,
    metadata?: Record<string, any>
  ): Promise<void> {
    try {
      const qerrors = await loadQerrors();
      if (qerrors?.ErrorFactory && qerrors?.handleControllerError) {
        const error = qerrors.ErrorFactory.validation(message, fieldName);
        await qerrors.handleControllerError?.(res, error, controllerName, metadata);
        return;
      }
    } catch {
      // Fall through to standard response on any error
    }
    // Fallback to standard validation error response
    await sendValidationError(res, message);
  };
}
/**
 * Validates required string field in request body.
 *
 * @param req - Express request object
 * @param res - Express response object
 * @param fieldName - Name of field to validate
 * @param handler - Validation error handler for the controller
 * @returns The validated string value or null if validation failed
 */
export async function validateRequiredString(
  req: Request,
  res: Response,
  fieldName: string,
  handler: ReturnType<typeof createValidationErrorHandler>
): Promise<string | null> {
  const value = req.body[fieldName];
  if (!value) {
    await handler(res, `Missing required field: ${fieldName}`, fieldName, {
      receivedValue: value,
      body: req.body
    });
    return null;
  }
  if (typeof value !== 'string') {
    await handler(res, `${fieldName} must be a string`, fieldName, {
      receivedValue: value,
      receivedType: typeof value,
      body: req.body
    });
    return null;
  }
  return value;
}
/**
 * Validates numeric field with range constraints.
 *
 * @param req - Express request object
 * @param res - Express response object
 * @param fieldName - Name of field to validate
 * @param min - Minimum allowed value (optional)
 * @param max - Maximum allowed value (optional)
 * @param handler - Validation error handler for the controller
 * @returns The validated number value or null if validation failed
 */
export async function validateNumberInRange(
  req: Request,
  res: Response,
  fieldName: string,
  min?: number,
  max?: number,
  handler?: ReturnType<typeof createValidationErrorHandler>
): Promise<number | null> {
  const value = req.body[fieldName];
  if (value === undefined || value === null) {
    return null;
  }
  if (!Number.isFinite(value)) {
    if (handler) {
      await handler(res, `${fieldName} must be a number`, fieldName, {
        receivedValue: value,
        receivedType: typeof value,
        body: req.body
      });
    }
    return null;
  }
  if ((min !== undefined && value < min) || (max !== undefined && value > max)) {
    if (handler) {
      const range = min !== undefined && max !== undefined 
        ? `between ${min} and ${max}`
        : min !== undefined 
          ? `greater than or equal to ${min}`
          : `less than or equal to ${max}`;
      
      await handler(res, `${fieldName} must be ${range}`, fieldName, {
        receivedValue: value,
        min,
        max,
        body: req.body
      });
    }
    return null;
  }
  return value;
}
/**
 * Validates boolean field in request body.
 *
 * @param req - Express request object
 * @param res - Express response object
 * @param fieldName - Name of field to validate
 * @param handler - Validation error handler for the controller
 * @param defaultValue - Default value if field is not present
 * @returns The validated boolean value or default
 */
export async function validateBoolean(
  req: Request,
  res: Response,
  fieldName: string,
  handler: ReturnType<typeof createValidationErrorHandler>,
  defaultValue?: boolean
): Promise<boolean> {
  const value = req.body[fieldName];
  if (value === undefined || value === null) {
    return defaultValue !== undefined ? defaultValue : false;
  }
  if (typeof value !== 'boolean') {
    await handler(res, `${fieldName} must be a boolean`, fieldName, {
      receivedValue: value,
      receivedType: typeof value,
      body: req.body
    });
    return false;
  }
  return value;
}

@codex/validation-responder
Purpose: Standardized validation error responder with optional library integration. Explanation:
This module provides a standardized way to handle validation failures in Express applications with optional integration for specialized error handling libraries. It solves the problem of inconsistent validation error responses by offering a unified interface that can integrate with libraries like qerrors when available, while falling back to standard HTTP errors when they're not. The responder ensures consistent error formatting and proper HTTP status codes across the application.

The module is particularly useful for applications that want to maintain consistent validation error responses, integrate with optional error handling libraries, and provide proper error context and metadata for debugging.

import type { Response } from 'express';
import createError from 'http-errors';
interface ValidationResponderOptions {
  /** Express response object used by qerrors when available */
  res: Response;
  /** Validation message shown to API clients */
  message: string;
  /** Name of the field that failed validation */
  field: string;
  /** Request context used for qerrors instrumentation */
  context: string;
  /** Optional metadata that supplies extra debugging data */
  metadata?: Record<string, unknown>;
  /** Optional qerrors helper interface */
  qerrors?: Record<string, any>;
}
/**
 * Sends a qerrors-powered validation failure when available, otherwise throws
 * a standard HTTP 400 error so express-async-errors can finish the response.
 */
export async function handleValidationFailure(options: ValidationResponderOptions): Promise<void> {
  const { res, field, message, metadata, context, qerrors } = options;
  if (qerrors && qerrors.ErrorFactory && typeof qerrors.handleControllerError === 'function') {
    const error = qerrors.ErrorFactory.validation(message, field);
    await qerrors.handleControllerError(res, error, context, metadata);
    return;
  }
  const validationError = createError.BadRequest(message);
  validationError.details = metadata;
  (validationError as unknown as Record<string, unknown>).field = field;
  throw validationError;
}