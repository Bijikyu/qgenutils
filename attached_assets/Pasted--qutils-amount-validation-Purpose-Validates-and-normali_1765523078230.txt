@qutils/amount-validation
Purpose: Validates and normalizes payment amounts with Express integration.

Explanation:
This utility provides robust validation for payment amounts, ensuring they are positive numbers and properly formatted for Stripe integration. It solves the common problem of inconsistent amount validation across payment controllers by providing a standardized validation function that returns normalized integer values (cents) suitable for payment processing. The module is broadly applicable to any Node.js application handling monetary inputs, particularly e-commerce platforms, payment gateways, and financial services. It takes unknown input, validates it against business rules, and returns either a validated normalized amount or sends an appropriate 400 error response via Express.

/**
 * @file amountValidation.ts
 * @description Utility for normalizing and validating payment amounts (utils scope).
 */
import type{Response}from'express';
import{parsePositiveNumber}from'./numberGuards.js';
/**
 * @file amountValidation.ts
 * @description Shared helpers for normalizing and validating payment amounts across controllers.
 *
 * Rationale:
 * - Consolidates the repeated positive-amount guard so controllers stay focused on orchestration.
 * - Returns the normalized integer value so callers do not repeat `Math.trunc` boilerplate.
 * - Emits the existing 400 response directly to match prior behavior without branching changes.
 */
interface PositiveAmountValidationInput{amount:unknown;res:Response;errorMessage?:string;}
const validatePositiveAmount=(input:PositiveAmountValidationInput):{ok:true;value:number}|{ok:false}=>{
	const schema=z.preprocess((val)=>(typeof val==='number'||typeof val==='string')?Number(val):val,z.number().finite().gt(0));
	const result=schema.safeParse(input.amount);
	if(!result.success){
		input.res.status(400).json({error:input.errorMessage||'Amount must be a positive number'});
		return{ok:false};
	}
	return{ok:true,value:Math.trunc(result.value)};
}
export type{PositiveAmountValidationInput};
export{validatePositiveAmount};

@qutils/number-guards
Purpose: Provides type-safe number parsing and validation primitives.

Explanation:
A fundamental utility for parsing and validating numeric inputs that replaces repetitive type checking and validation logic. This module solves the ubiquitous problem of safely converting unknown inputs (strings, numbers, etc.) into validated numeric values while handling edge cases like NaN, infinity, and negative values. It's broadly applicable across any Node.js application that processes user input, API parameters, configuration values, or external data. The utility uses Zod for robust schema validation and provides a simple, consistent API for number validation that can be used throughout an application stack.

/**
 * @file numberGuards.ts
 * @description Shared primitives for validating and coercing numeric inputs.
 */
import{z}from'zod';
export const parsePositiveNumber=(value:unknown):{ok:true;value:number}|{ok:false}=>{
	const schema=z.preprocess((val)=>(typeof val==='number'||typeof val==='string')?Number(val):val,z.number().finite().gt(0));
	const result=schema.safeParse(value);
	return!result.success?{ok:false}:{ok:true,value:result.data};
}

@qutils/url-validator
Purpose: Secure URL validation with domain allowlisting to prevent SSRF attacks.

Explanation:
This security-focused utility validates URLs against an allowlist of permitted domains, providing critical protection against Server-Side Request Forgery (SSRF) attacks. It solves the security problem of arbitrary URL redirection or external API calls by ensuring only approved domains can be accessed. The module is broadly applicable to any application that makes external HTTP requests based on user input, particularly microservices, API gateways, and web applications with third-party integrations. It provides URL parsing, domain validation with wildcard subdomain support, path normalization to prevent directory traversal, and both boolean validation and error-throwing interfaces.

/**
 * @file urlValidator.ts
 * @description URL validation utility for external API calls with domain allowlisting.
 * Provides centralized validation to prevent SSRF attacks.
 */
/**
 * Validates that a URL belongs to an allowed domain
 * @param url The URL to validate
 * @param allowedDomains Comma-separated list of allowed domains
 * @returns true if the URL domain is allowed, false otherwise
 * @throws Error if URL is malformed
 */
export const isAllowedExternalUrl = (url: string, allowedDomains: string): boolean => {
	try {
		const urlObj = new URL(url);
		const domains = allowedDomains.split(',').map((domain: string) => domain.trim());
		
		return domains.some((allowedDomain: string) => {
			// Exact match
			if (urlObj.hostname === allowedDomain) {
				return true;
			}
			// Wildcard subdomain support (*.example.com)
			if (allowedDomain.startsWith('*.')) {
				const baseDomain = allowedDomain.slice(2);
				return urlObj.hostname === baseDomain || urlObj.hostname.endsWith('.' + baseDomain);
			}
			return false;
		});
	} catch (error) {
		throw new Error(`Invalid URL format: ${url}`);
	}
};
/**
 * Validates and throws an error for disallowed URLs
 * @param url The URL to validate
 * @param allowedDomains Comma-separated list of allowed domains
 * @throws Error if URL is not allowed or is malformed
 */
export const validateExternalUrl = (url: string, allowedDomains: string): void => {
	if (!isAllowedExternalUrl(url, allowedDomains)) {
		throw new Error(`URL domain not allowed: ${new URL(url).hostname}`);
	}
};
/**
 * Builds a safe external URL with validation
 * @param baseUrl The base URL (must be allowed)
 * @param path Path to append (optional)
 * @param allowedDomains Comma-separated list of allowed domains
 * @returns Validated full URL
 * @throws Error if base URL is not allowed
 */
export const buildSafeExternalUrl = (baseUrl: string, path?: string, allowedDomains?: string): string => {
	if (allowedDomains) {
		validateExternalUrl(baseUrl, allowedDomains);
	}
	
	const url = new URL(baseUrl);
	if (path) {
		// Normalize path to prevent directory traversal
		const cleanPath = path.replace(/\.\./g, '').replace(/\/+/g, '/');
		url.pathname = url.pathname.replace(/\/$/, '') + '/' + cleanPath.replace(/^\//, '');
	}
	
	return url.toString();
};