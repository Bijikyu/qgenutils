Validation Modules
@input-validator/core
Purpose: Provides comprehensive input validation utilities for Node.js applications with reusable validation patterns.

Explanation: This utility eliminates duplicate validation logic by providing a set of reusable validation functions that can check common data types, ranges, patterns, and business rules. It solves the problem of inconsistent validation across different parts of an application while providing clear error messages. The module is framework-agnostic and can be used in any Node.js project needing input validation, from web APIs to data processing pipelines.

Where it would be reused: Web applications, APIs, form validation, data processing scripts, microservices, database operations.

Inputs/Outputs: Takes data values and validation rules, returns error objects or null for valid data.

Edge cases: Handles null/undefined values, type checking, string validation, arrays, dates, and custom validation patterns.

/**
 * Validation utility functions for standardizing input validation
 * Replaced with qgenutils and qaccessibility functionality to eliminate duplication
 */
const { 
  requireFields,
  isValidString,
  isValidObject,
  hasMethod
} = require('qgenutils');
const { validateEmail: validateEmailFromQaccessibility } = require('@bijikyu/qaccessibility');
/**
 * Validates required fields in request data - uses qgenutils requireFields
 * @param {Object} data - Request data object to validate
 * @param {Array} requiredFields - Array of required field names
 * @param {Object} res - Express response object (optional)
 * @returns {Object|null} Validation error object or null if valid
 */
const validateRequired = (data, requiredFields, res = null) => {
  // Add null check to prevent runtime errors
  if (!data || typeof data !== 'object') {
    return { 
      error: 'Invalid data object provided',
      required: requiredFields
    };
  }
  
  const result = requireFields(data, requiredFields, res);
  return result === true ? null : { 
    error: 'Missing required fields',
    required: requiredFields.filter(field => !data[field])
  };
};
/**
 * Validates that a value is in allowed enum values
 * @param {*} value - Value to validate
 * @param {Array} validValues - Array of valid values
 * @param {string} fieldName - Name of field for error messages
 * @returns {Object|null} Validation error object or null if valid
 */
const validateEnum = (value, validValues, fieldName) => {
  return validValues.includes(value) ? null : {
    error: `Invalid ${fieldName}`,
    validOptions: validValues
  };
};
/**
 * Validates email format using qaccessibility validateEmail
 * @param {string} email - Email address to validate
 * @returns {Object|null} Validation error object or null if valid
 */
const validateEmail = (email) => {
  // qaccessibility validateEmail returns boolean (true for valid, false for invalid)
  const isValid = validateEmailFromQaccessibility(email);
  return isValid ? null : {
    error: 'Invalid email format'
  };
};
/**
 * Validates that a string is not empty or just whitespace - uses qgenutils isValidString
 * @param {string} value - String value to validate
 * @param {string} fieldName - Name of field for error messages
 * @returns {Object|null} Validation error object or null if valid
 */
const validateNonEmpty = (value, fieldName) => {
  return isValidString(value) ? null : {
    error: `${fieldName} cannot be empty`
  };
};
/**
 * Validates numeric value within range
 * @param {number} value - Numeric value to validate
 * @param {number} min - Minimum allowed value
 * @param {number} max - Maximum allowed value
 * @param {string} fieldName - Name of field for error messages
 * @returns {Object|null} Validation error object or null if valid
 */
const validateNumberRange = (value, min, max, fieldName) => {
  const numValue = Number(value);
  if (isNaN(numValue)) {
    return {
      error: `${fieldName} must be a number`
    };
  }
  
  if (numValue < min || numValue > max) {
    return {
      error: `${fieldName} must be between ${min} and ${max}`
    };
  }
  
  return null;
};
/**
 * Validates string length
 * @param {string} value - String value to validate
 * @param {number} minLength - Minimum allowed length
 * @param {number} maxLength - Maximum allowed length
 * @param {string} fieldName - Name of field for error messages
 * @returns {Object|null} Validation error object or null if valid
 */
const validateStringLength = (value, minLength, maxLength, fieldName) => {
  if (typeof value !== 'string') {
    return {
      error: `${fieldName} must be a string`
    };
  }
  
  if (value.length < minLength) {
    return {
      error: `${fieldName} must be at least ${minLength} characters long`
    };
  }
  
  if (value.length > maxLength) {
    return {
      error: `${fieldName} must be no more than ${maxLength} characters long`
    };
  }
  
  return null;
};
/**
 * Validates array of items
 * @param {*} value - Value to validate as array
 * @param {number} minLength - Minimum array length
 * @param {number} maxLength - Maximum array length
 * @param {string} fieldName - Name of field for error messages
 * @returns {Object|null} Validation error object or null if valid
 */
const validateArray = (value, minLength = 0, maxLength = Infinity, fieldName) => {
  if (!Array.isArray(value)) {
    return {
      error: `${fieldName} must be an array`
    };
  }
  
  if (value.length < minLength) {
    return {
      error: `${fieldName} must contain at least ${minLength} items`
    };
  }
  
  if (value.length > maxLength) {
    return {
      error: `${fieldName} must contain no more than ${maxLength} items`
    };
  }
  
  return null;
};
/**
 * Creates a validator function for multiple validation rules
 * @param {Array} validations - Array of validation functions to run
 * @returns {Function} Validator function that runs all validations
 */
const createValidator = (validations) => {
  return (data) => {
    const errors = [];
    
    for (const validation of validations) {
      const error = validation(data);
      if (error) {
        errors.push(error);
      }
    }
    
    return errors.length === 0 ? null : { errors };
  };
};
/**
 * Runs multiple validations and returns first error found
 * @param {Array} validations - Array of validation functions
 * @returns {Object|null} First validation error or null if all pass
 */
const validateFirst = (validations) => {
  for (const validation of validations) {
    const error = validation();
    if (error) {
      return error;
    }
  }
  return null;
};
/**
 * Validates that a field matches a regex pattern
 * @param {string} value - Value to validate
 * @param {RegExp} pattern - Regex pattern to match
 * @param {string} fieldName - Name of field for error messages
 * @param {string} customMessage - Custom error message
 * @returns {Object|null} Validation error object or null if valid
 */
const validatePattern = (value, pattern, fieldName, customMessage) => {
  if (typeof value !== 'string') {
    return {
      error: `${fieldName} must be a string`
    };
  }
  
  return pattern.test(value) ? null : {
    error: customMessage || `${fieldName} format is invalid`
  };
};
/**
 * Validates boolean field
 * @param {*} value - Value to validate
 * @param {string} fieldName - Name of field for error messages
 * @returns {Object|null} Validation error object or null if valid
 */
const validateBoolean = (value, fieldName) => {
  return typeof value === 'boolean' ? null : {
    error: `${fieldName} must be true or false`
  };
};
/**
 * Validates date field
 * @param {*} value - Value to validate
 * @param {string} fieldName - Name of field for error messages
 * @returns {Object|null} Validation error object or null if valid
 */
const validateDate = (value, fieldName) => {
  const date = new Date(value);
  return !isNaN(date.getTime()) ? null : {
    error: `${fieldName} must be a valid date`
  };
};
/**
 * Validates CRUD create operations
 * @param {Object} data - Request data object to validate
 * @param {Array} requiredFields - Array of required field names
 * @param {string} resourceType - Type of resource for error messages
 * @returns {Object|null} Validation error object or null if valid
 */
const validateCrudCreate = (data, requiredFields, resourceType) => {
  const missingError = validateRequired(data, requiredFields);
  if (missingError) {
    return {
      error: `Missing required fields for ${resourceType}`,
      required: requiredFields,
      missing: missingError.required
    };
  }
  return null;
};
/**
 * Validates CRUD update operations
 * @param {Object} data - Request data object to validate
 * @param {Array} allowedFields - Array of allowed field names for update
 * @param {string} resourceType - Type of resource for error messages
 * @returns {Object|null} Validation error object or null if valid
 */
const validateCrudUpdate = (data, allowedFields, resourceType) => {
  const invalidFields = Object.keys(data).filter(field => !allowedFields.includes(field));
  if (invalidFields.length > 0) {
    return {
      error: `Invalid fields for ${resourceType} update`,
      allowedFields,
      invalidFields
    };
  }
  
  if (Object.keys(data).length === 0) {
    return {
      error: `At least one field must be provided for ${resourceType} update`
    };
  }
  
  return null;
};
/**
 * Validates MongoDB ObjectId
 * @param {string} id - ObjectId string to validate
 * @param {string} fieldName - Name of field for error messages
 * @returns {Object|null} Validation error object or null if valid
 */
const validateObjectId = (id, fieldName = 'id') => {
  const objectIdRegex = /^[0-9a-fA-F]{24}$/;
  return objectIdRegex.test(id) ? null : {
    error: `Invalid ${fieldName} format`,
    details: `${fieldName} must be a valid ObjectId`
  };
};
/**
 * Validates pagination parameters
 * @param {Object} params - Pagination parameters
 * @returns {Object|null} Validation error object or null if valid
 */
const validatePagination = (params) => {
  const { page = 1, limit = 10 } = params;
  
  const pageError = validateNumberRange(page, 1, 1000, 'page');
  if (pageError) return pageError;
  
  const limitError = validateNumberRange(limit, 1, 100, 'limit');
  if (limitError) return limitError;
  
  return null;
};
/**
 * Validates search parameters
 * @param {Object} params - Search parameters
 * @returns {Object|null} Validation error object or null if valid
 */
const validateSearch = (params) => {
  const { query, sortBy, sortOrder } = params;
  
  if (query !== undefined) {
    const queryError = validateStringLength(query, 1, 100, 'search query');
    if (queryError) return queryError;
  }
  
  if (sortBy !== undefined) {
    const validSortFields = ['name', 'createdAt', 'updatedAt', 'category'];
    const sortError = validateEnum(sortBy, validSortFields, 'sort field');
    if (sortError) return sortError;
  }
  
  if (sortOrder !== undefined) {
    const validSortOrders = ['asc', 'desc'];
    const orderError = validateEnum(sortOrder, validSortOrders, 'sort order');
    if (orderError) return orderError;
  }
  
  return null;
};
/**
 * Creates a resource-specific validator
 * @param {string} resourceType - Type of resource
 * @param {Array} requiredFields - Required fields for create
 * @param {Array} allowedFields - Allowed fields for update
 * @param {Object} fieldValidators - Object with field-specific validation functions
 * @returns {Object} Object with create and update validators
 */
const createResourceValidator = (resourceType, requiredFields, allowedFields, fieldValidators = {}) => {
  return {
    create: (data) => {
      const crudError = validateCrudCreate(data, requiredFields, resourceType);
      if (crudError) return crudError;
      
      // Run field-specific validations
      for (const [field, validator] of Object.entries(fieldValidators)) {
        if (data[field] !== undefined) {
          const error = validator(data[field], field);
          if (error) return error;
        }
      }
      
      return null;
    },
    
    update: (data) => {
      const crudError = validateCrudUpdate(data, allowedFields, resourceType);
      if (crudError) return crudError;
      
      // Run field-specific validations for provided fields
      for (const [field, validator] of Object.entries(fieldValidators)) {
        if (data[field] !== undefined) {
          const error = validator(data[field], field);
          if (error) return error;
        }
      }
      
      return null;
    }
  };
};
module.exports = {
  validateRequired,
  validateEnum,
  validateEmail,
  validateNonEmpty,
  validateNumberRange,
  validateStringLength,
  validateArray,
  createValidator,
  validateFirst,
  validatePattern,
  validateBoolean,
  validateDate,
  validateCrudCreate,
  validateCrudUpdate,
  validateObjectId,
  validatePagination,
  validateSearch,
  createResourceValidator,
  // Export qgenutils functions for direct access
  requireFields,
  isValidString,
  isValidObject,
  hasMethod
};