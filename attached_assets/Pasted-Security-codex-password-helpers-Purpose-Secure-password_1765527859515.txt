Security
@codex/password-helpers
Purpose: Secure password hashing utility with bcrypt and strength validation. Explanation:
This module provides comprehensive password security functionality including bcrypt-based hashing, constant-time comparison, and password strength validation. It solves the common security problem of improper password handling by offering secure defaults (12 salt rounds), input validation, and constant-time comparison to prevent timing attacks. The module includes password strength requirements, secure random password generation, and proper error handling without information leakage.

The module is essential for any application that handles user authentication, password management, or secure credential storage. It follows OWASP recommendations and provides defense against common password-related attacks.

/**
 * Secure Password Hashing Utility
 * 
 * Provides bcrypt-based password hashing with secure defaults
 * and constant-time comparison for authentication.
 * 
 * Security Features:
 * - bcrypt with 12 salt rounds (minimum recommended)
 * - Constant-time password comparison
 * - Input validation and sanitization
 * - Error handling without information leakage
 */
import bcrypt from 'bcrypt';
// Minimum password requirements
export const PASSWORD_REQUIREMENTS = {
  MIN_LENGTH: 8,
  MAX_LENGTH: 128,
  REQUIRE_UPPERCASE: true,
  REQUIRE_LOWERCASE: true,
  REQUIRE_NUMBERS: true,
  REQUIRE_SPECIAL_CHARS: false
} as const;
// bcrypt salt rounds - OWASP recommends minimum 12
export const BCRYPT_SALT_ROUNDS = 12;
/**
 * Validates password strength against security requirements
 * @param password - Plain text password to validate
 * @returns Validation result with boolean and error message
 */
export function validatePasswordStrength(password: string): { isValid: boolean; error?: string } {
  if (!password || typeof password !== 'string') {
    return { isValid: false, error: 'Password is required' };
  }
  if (password.length < PASSWORD_REQUIREMENTS.MIN_LENGTH) {
    return { 
      isValid: false, 
      error: `Password must be at least ${PASSWORD_REQUIREMENTS.MIN_LENGTH} characters long` 
    };
  }
  if (password.length > PASSWORD_REQUIREMENTS.MAX_LENGTH) {
    return { 
      isValid: false, 
      error: `Password must not exceed ${PASSWORD_REQUIREMENTS.MAX_LENGTH} characters` 
    };
  }
  if (PASSWORD_REQUIREMENTS.REQUIRE_UPPERCASE && !/[A-Z]/.test(password)) {
    return { isValid: false, error: 'Password must contain at least one uppercase letter' };
  }
  if (PASSWORD_REQUIREMENTS.REQUIRE_LOWERCASE && !/[a-z]/.test(password)) {
    return { isValid: false, error: 'Password must contain at least one lowercase letter' };
  }
  if (PASSWORD_REQUIREMENTS.REQUIRE_NUMBERS && !/\d/.test(password)) {
    return { isValid: false, error: 'Password must contain at least one number' };
  }
  return { isValid: true };
}
/**
 * Hashes a password using bcrypt with secure salt rounds
 * @param password - Plain text password to hash
 * @returns Promise resolving to bcrypt hash
 * @throws Error if hashing fails
 */
export async function hashPassword(password: string): Promise<string> {
  const validation = validatePasswordStrength(password);
  if (!validation.isValid) {
    throw new Error(`Invalid password: ${validation.error}`);
  }
  try {
    const hash = await bcrypt.hash(password, BCRYPT_SALT_ROUNDS);
    return hash;
  } catch (error) {
    // Log error without exposing sensitive information
    console.error('Password hashing failed:', error instanceof Error ? error.name : 'Unknown error');
    throw new Error('Password hashing failed');
  }
}
/**
 * Compares a plain text password against a bcrypt hash using constant-time comparison
 * @param password - Plain text password to verify
 * @param hash - bcrypt hash to compare against
 * @returns Promise resolving to boolean indicating match
 */
export async function verifyPassword(password: string, hash: string): Promise<boolean> {
  if (!password || !hash) {
    return false;
  }
  try {
    const isValid = await bcrypt.compare(password, hash);
    return isValid;
  } catch (error) {
    // Log error without exposing sensitive information
    console.error('Password verification failed:', error instanceof Error ? error.name : 'Unknown error');
    return false;
  }
}
/**
 * Generates a secure random password meeting all requirements
 * @param length - Optional password length (defaults to minimum + 4)
 * @returns Secure random password string
 */
export function generateSecurePassword(length: number = PASSWORD_REQUIREMENTS.MIN_LENGTH + 4): string {
  const minLength = Math.max(length, PASSWORD_REQUIREMENTS.MIN_LENGTH);
  const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  const lowercase = 'abcdefghijklmnopqrstuvwxyz';
  const numbers = '0123456789';
  const allChars = uppercase + lowercase + numbers;
  const passwordChars: string[] = [];
  
  // Ensure at least one of each required character type
  if (PASSWORD_REQUIREMENTS.REQUIRE_UPPERCASE) {
    passwordChars.push(uppercase[Math.floor(Math.random() * uppercase.length)]);
  }
  if (PASSWORD_REQUIREMENTS.REQUIRE_LOWERCASE) {
    passwordChars.push(lowercase[Math.floor(Math.random() * lowercase.length)]);
  }
  if (PASSWORD_REQUIREMENTS.REQUIRE_NUMBERS) {
    passwordChars.push(numbers[Math.floor(Math.random() * numbers.length)]);
  }
  // Fill remaining length with random characters
  for (let i = passwordChars.length; i < minLength; i++) {
    passwordChars.push(allChars[Math.floor(Math.random() * allChars.length)]);
  }
  // Shuffle password to avoid predictable patterns
  return passwordChars.sort(() => Math.random() - 0.5).join('');
}
export default {
  hashPassword,
  verifyPassword,
  validatePasswordStrength,
  generateSecurePassword,
  BCRYPT_SALT_ROUNDS,
  PASSWORD_REQUIREMENTS
};

@codex/secure-config
Purpose: Secure configuration management with validation and credential protection. Explanation:
This module provides comprehensive configuration management with security-focused validation, environment variable sanitization, and credential masking. It solves the problem of insecure configuration handling by offering validation schemas, secure defaults, credential masking for logs, and runtime security validation. The module uses convict for robust configuration validation and includes features like integrity verification and security warnings.

The module is essential for production applications that need secure configuration management, applications handling sensitive credentials, and deployments that require configuration validation and security compliance.

/**
 * Secure Configuration Management
 * 
 * Provides secure configuration handling with validation,
 * environment variable sanitization, and credential protection.
 * 
 * Security Features:
 * - Environment variable validation and sanitization
 * - Credential masking in logs
 * - Configuration integrity verification
 * - Secure default values
 * - Runtime configuration validation
 */
import { createHash, randomBytes } from 'crypto';
import convict from 'convict';
import type { Format } from 'convict';
// Configuration validation schemas
export const CONFIG_SCHEMA = {
  PORT: { type: 'number', min: 1, max: 65535, required: true },
  NODE_ENV: { type: 'string', enum: ['development', 'production', 'test'], required: true },
  API_KEY: { type: 'string', minLength: 16, required: false },
  REQUIRE_API_KEY: { type: 'boolean', required: false },
  RATE_LIMITING_ENABLED: { type: 'boolean', required: false },
  RATE_LIMIT_POINTS: { type: 'number', min: 1, max: 1000, required: false },
  RATE_LIMIT_DURATION: { type: 'number', min: 1, max: 3600, required: false },
  TF_BACKEND: { type: 'string', required: false },
  FACE_DETECTION_MIN_CONFIDENCE: { type: 'number', min: 0, max: 1, required: false },
  FACE_DETECTION_INPUT_SIZE: { type: 'number', min: 100, max: 1000, required: false },
  IMAGE_PROCESSING_MAX_WIDTH: { type: 'number', min: 100, max: 4096, required: false },
  IMAGE_PROCESSING_MAX_HEIGHT: { type: 'number', min: 100, max: 4096, required: false },
  UPSCALING_ENABLED: { type: 'boolean', required: false },
  UPSCALING_TIMEOUT_MS: { type: 'number', min: 1000, max: 300000, required: false }
} as const;
// Secure defaults for production
export const SECURE_DEFAULTS = {
  PORT: 5000,
  NODE_ENV: 'development',
  REQUIRE_API_KEY: true,
  RATE_LIMITING_ENABLED: true,
  RATE_LIMIT_POINTS: 100,
  RATE_LIMIT_DURATION: 900, // 15 minutes
  TF_BACKEND: 'tensorflow',
  FACE_DETECTION_MIN_CONFIDENCE: 0.5,
  FACE_DETECTION_INPUT_SIZE: 416,
  IMAGE_PROCESSING_MAX_WIDTH: 2048,
  IMAGE_PROCESSING_MAX_HEIGHT: 2048,
  UPSCALING_ENABLED: true,
  UPSCALING_TIMEOUT_MS: 30000
} as const;
convict.addFormat({
  name: 'float',
  coerce: (value: unknown) => Number(value),
  validate: (value: unknown) => {
    if (typeof value === 'number' && !Number.isFinite(value)) {
      throw new Error('must be a finite number');
    }
  }
} satisfies Format);
const convictSchema = {
  PORT: {
    doc: 'Port on which the FaceQrop API listens',
    format: 'port',
    default: SECURE_DEFAULTS.PORT
  },
  NODE_ENV: {
    doc: 'Runtime environment',
    format: ['development', 'production', 'test'],
    default: SECURE_DEFAULTS.NODE_ENV
  },
  API_KEY: {
    doc: 'Optional API key for protected routes',
    format: String,
    default: ''
  },
  REQUIRE_API_KEY: {
    doc: 'Require API key for protected endpoints',
    format: 'Boolean',
    default: SECURE_DEFAULTS.REQUIRE_API_KEY
  },
  RATE_LIMITING_ENABLED: {
    doc: 'Enable rate limiting middleware',
    format: 'Boolean',
    default: SECURE_DEFAULTS.RATE_LIMITING_ENABLED
  },
  RATE_LIMIT_POINTS: {
    doc: 'Number of rate limit points (requests)',
    format: 'nat',
    default: SECURE_DEFAULTS.RATE_LIMIT_POINTS
  },
  RATE_LIMIT_DURATION: {
    doc: 'Rate limit window duration in seconds',
    format: 'nat',
    default: SECURE_DEFAULTS.RATE_LIMIT_DURATION
  },
  TF_BACKEND: {
    doc: 'Preferred TensorFlow backend',
    format: String,
    default: SECURE_DEFAULTS.TF_BACKEND
  },
  FACE_DETECTION_MIN_CONFIDENCE: {
    doc: 'Minimum confidence threshold for face detection',
    format: 'float',
    default: SECURE_DEFAULTS.FACE_DETECTION_MIN_CONFIDENCE
  },
  FACE_DETECTION_INPUT_SIZE: {
    doc: 'Maximum input size for face detection tensors',
    format: 'nat',
    default: SECURE_DEFAULTS.FACE_DETECTION_INPUT_SIZE
  },
  IMAGE_PROCESSING_MAX_WIDTH: {
    doc: 'Maximum width for image processing',
    format: 'nat',
    default: SECURE_DEFAULTS.IMAGE_PROCESSING_MAX_WIDTH
  },
  IMAGE_PROCESSING_MAX_HEIGHT: {
    doc: 'Maximum height for image processing',
    format: 'nat',
    default: SECURE_DEFAULTS.IMAGE_PROCESSING_MAX_HEIGHT
  },
  UPSCALING_ENABLED: {
    doc: 'Enable AI upscaling',
    format: 'Boolean',
    default: SECURE_DEFAULTS.UPSCALING_ENABLED
  },
  UPSCALING_TIMEOUT_MS: {
    doc: 'Timeout for upscaling operations in milliseconds',
    format: 'nat',
    default: SECURE_DEFAULTS.UPSCALING_TIMEOUT_MS
  }
} as const;
function buildConvictConfig(env: NodeJS.ProcessEnv) {
  const envOverrides: Record<string, unknown> = {};
  for (const key of Object.keys(convictSchema)) {
    if (env[key] !== undefined) {
      envOverrides[key] = env[key];
    }
  }
  const config = convict(convictSchema);
  config.load(envOverrides);
  config.validate({ allowed: 'strict' });
  return config.getProperties() as Record<string, any>;
}
/**
 * Masks sensitive values for logging
 * @param value - Value to mask
 * @param key - Configuration key name
 * @returns Masked value safe for logging
 */
export function maskSensitiveValue(value: string, key: string): string {
  const sensitiveKeys = ['api_key', 'password', 'secret', 'token', 'key'];
  const isSensitive = sensitiveKeys.some(sensitive => key.toLowerCase().includes(sensitive));
  
  if (!isSensitive || !value) {
    return value;
  }
  
  if (value.length <= 4) {
    return '*'.repeat(value.length);
  }
  
  return value.substring(0, 2) + '*'.repeat(value.length - 4) + value.substring(value.length - 2);
}
/**
 * Validates a configuration value against its schema
 * @param key - Configuration key
 * @param value - Value to validate
 * @returns Validation result
 */
export function validateConfigValue(key: string, value: any): { isValid: boolean; error?: string } {
  const schema = CONFIG_SCHEMA[key as keyof typeof CONFIG_SCHEMA];
  if (!schema) {
    return { isValid: true }; // Unknown keys pass validation
  }
  
  // Type validation
  if (schema.type === 'number' && typeof value !== 'number') {
    const numValue = Number(value);
    if (isNaN(numValue)) {
      return { isValid: false, error: `${key} must be a number` };
    }
    value = numValue;
  } else if (schema.type === 'boolean' && typeof value !== 'boolean') {
    if (value === 'true' || value === '1') {
      value = true;
    } else if (value === 'false' || value === '0') {
      value = false;
    } else {
      return { isValid: false, error: `${key} must be a boolean` };
    }
  } else if (schema.type === 'string' && typeof value !== 'string') {
    value = String(value);
  }
  
  // Enum validation
  if ('enum' in schema && schema.enum && !schema.enum.includes(value)) {
    return { 
      isValid: false, 
      error: `${key} must be one of: ${schema.enum.join(', ')}` 
    };
  }
  
  // Range validation
  if ('min' in schema && schema.min !== undefined && value < schema.min) {
    return { 
      isValid: false, 
      error: `${key} must be at least ${schema.min}` 
    };
  }
  
  if ('max' in schema && schema.max !== undefined && value > schema.max) {
    return { 
      isValid: false, 
      error: `${key} must be at most ${schema.max}` 
    };
  }
  
  // Length validation for strings
  if (schema.type === 'string' && 'minLength' in schema && schema.minLength && value.length < schema.minLength) {
    return { 
      isValid: false, 
      error: `${key} must be at least ${schema.minLength} characters long` 
    };
  }
  
  return { isValid: true };
}
/**
 * Sanitizes and validates environment variables
 * @param env - Raw environment variables
 * @returns Sanitized and validated configuration
 */
export function sanitizeConfiguration(env: NodeJS.ProcessEnv): Record<string, any> {
  const errors: string[] = [];
  let config: Record<string, any>;
  
  try {
    config = buildConvictConfig(env);
  } catch (error) {
    throw new Error(`Configuration validation failed:\n${error instanceof Error ? error.message : String(error)}`);
  }
  for (const key of Object.keys(CONFIG_SCHEMA)) {
    const validation = validateConfigValue(key, config[key]);
    if (!validation.isValid) {
      errors.push(`${key}: ${validation.error}`);
    }
  }
  // Special handling for API key
  if (config.REQUIRE_API_KEY && !config.API_KEY) {
    errors.push('API_KEY: Required when REQUIRE_API_KEY is true');
  }
  
  if (errors.length > 0) {
    throw new Error(`Configuration validation failed:\n${errors.join('\n')}`);
  }
  
  return config;
}
/**
 * Generates a secure random API key
 * @param length - Key length in bytes (default 32)
 * @returns Secure random API key
 */
export function generateSecureApiKey(length: number = 32): string {
  return randomBytes(length).toString('hex');
}
/**
 * Creates a configuration hash for integrity verification
 * @param config - Configuration object
 * @returns SHA-256 hash of configuration
 */
export function createConfigHash(config: Record<string, any>): string {
  // Create a normalized string representation
  const normalizedConfig = Object.keys(config)
    .sort()
    .map(key => `${key}=${maskSensitiveValue(String(config[key]), key)}`)
    .join('|');
  
  return createHash('sha256').update(normalizedConfig).digest('hex');
}
/**
 * Validates configuration integrity
 * @param config - Current configuration
 * @param expectedHash - Expected configuration hash
 * @returns Integrity check result
 */
export function verifyConfigIntegrity(config: Record<string, any>, expectedHash: string): boolean {
  const currentHash = createConfigHash(config);
  return currentHash === expectedHash;
}
/**
 * Creates a secure configuration object with masked sensitive values
 * @param config - Raw configuration
 * @returns Configuration safe for logging/export
 */
export function createSafeConfig(config: Record<string, any>): Record<string, any> {
  const safeConfig: Record<string, any> = {};
  
  for (const [key, value] of Object.entries(config)) {
    if (typeof value === 'string') {
      safeConfig[key] = maskSensitiveValue(value, key);
    } else {
      safeConfig[key] = value;
    }
  }
  
  return safeConfig;
}
/**
 * Runtime configuration validation
 * Validates that the current configuration meets security requirements
 * @param config - Configuration to validate
 * @returns Security validation result
 */
export function validateSecurityConfiguration(config: Record<string, any>): {
  isSecure: boolean;
  warnings: string[];
  errors: string[];
} {
  const warnings: string[] = [];
  const errors: string[] = [];
  
  // Production security checks
  if (config.NODE_ENV === 'production') {
    if (!config.REQUIRE_API_KEY) {
      warnings.push('API key authentication is disabled in production');
    }
    
    if (!config.RATE_LIMITING_ENABLED) {
      warnings.push('Rate limiting is disabled in production');
    }
    
    if (config.API_KEY && config.API_KEY.length < 32) {
      warnings.push('API key should be at least 32 characters in production');
    }
  }
  
  // General security checks
  if (config.FACE_DETECTION_MIN_CONFIDENCE < 0.5) {
    warnings.push('Face detection confidence threshold is very low, may affect accuracy');
  }
  
  if (config.IMAGE_PROCESSING_MAX_WIDTH > 4096 || config.IMAGE_PROCESSING_MAX_HEIGHT > 4096) {
    warnings.push('Large image processing dimensions may impact performance');
  }
  
  if (config.UPSCALING_TIMEOUT_MS > 120000) {
    warnings.push('Very long upscaling timeout may cause resource exhaustion');
  }
  
  return {
    isSecure: errors.length === 0,
    warnings,
    errors
  };
}
export default {
  maskSensitiveValue,
  validateConfigValue,
  sanitizeConfiguration,
  generateSecureApiKey,
  createConfigHash,
  verifyConfigIntegrity,
  createSafeConfig,
  validateSecurityConfiguration,
  CONFIG_SCHEMA,
  SECURE_DEFAULTS
};

@codex/image-validation
Purpose: Comprehensive image validation utility with security checks and format verification. Explanation:
This module provides thorough image validation for base64-encoded images with security-focused checks. It solves the problem of insecure image handling by offering comprehensive validation including format verification, size limits, malicious pattern detection, and content-based validation. The module uses multiple libraries (Jimp, file-type) for robust image type detection and includes security features like XSS pattern scanning and dimension validation.

The module is essential for applications that handle user-uploaded images, APIs that process base64 image data, and systems that need to validate image content for security and performance reasons.

/**
 * Image Validation Utility
 * 
 * Provides comprehensive validation for base64-encoded images
 * with security checks, format validation, and content verification.
 *
 * Security Features:
 * - Base64 format validation
 * - Image file type verification
 * - File size limitations
 * - Malicious payload detection
 * - Content-based image validation
 */
import { createHash } from 'crypto';
import { Jimp } from 'jimp';
import { fileTypeFromBuffer } from 'file-type';
// Image validation configuration
export const IMAGE_VALIDATION_CONFIG = {
  // File size limits (in bytes)
  MAX_FILE_SIZE: 10 * 1024 * 1024, // 10MB
  MIN_FILE_SIZE: 1024, // 1KB
  
  // Supported image formats
  SUPPORTED_FORMATS: ['jpeg', 'jpg', 'png', 'webp'],
  
  // Base64 validation
  BASE64_MIN_LENGTH: 100, // Minimum reasonable base64 length
  BASE64_MAX_LENGTH: 14_336_000, // ~10MB encoded
  
  // Security checks
  MAX_DIMENSION: 8192, // Maximum width/height in pixels
  ALLOWED_MIME_TYPES: [
    'image/jpeg',
    'image/jpg', 
    'image/png',
    'image/webp'
  ],
  
  // Content validation
  REQUIRE_VALID_IMAGE_HEADERS: true,
  SCAN_FOR_MALICIOUS_PATTERNS: true
} as const;
// Malicious patterns to scan for
const MALICIOUS_PATTERNS = [
  /<script/i,
  /javascript:/i,
  /vbscript:/i,
  /data:script/i,
  /<iframe/i,
  /<object/i,
  /<embed/i,
  /eval\s*\(/i,
  /exec\s*\(/i,
  /system\s*\(/i
];
/**
 * Validates base64 string format
 */
export function validateBase64Format(base64String: string): { 
  isValid: boolean; 
  error?: string; 
  format?: string; 
  data?: string;
} {
  if (!base64String || typeof base64String !== 'string') {
    return { isValid: false, error: 'Base64 string is required' };
  }
  if (base64String.length < IMAGE_VALIDATION_CONFIG.BASE64_MIN_LENGTH) {
    return { 
      isValid: false, 
      error: `Base64 string too short (minimum ${IMAGE_VALIDATION_CONFIG.BASE64_MIN_LENGTH} characters)` 
    };
  }
  if (base64String.length > IMAGE_VALIDATION_CONFIG.BASE64_MAX_LENGTH) {
    return { 
      isValid: false, 
      error: `Base64 string too long (maximum ${IMAGE_VALIDATION_CONFIG.BASE64_MAX_LENGTH} characters)` 
    };
  }
  const dataUrlMatch = base64String.match(/^data:image\/([a-z]+);base64,(.+)$/i);
  if (!dataUrlMatch) {
    return { isValid: false, error: 'Invalid data URL format. Expected: data:image/[format];base64,[data]' };
  }
  const format = dataUrlMatch[1].toLowerCase();
  const data = dataUrlMatch[2];
  if (!IMAGE_VALIDATION_CONFIG.SUPPORTED_FORMATS.includes(format as any)) {
    return { 
      isValid: false, 
      error: `Unsupported image format: ${format}. Supported formats: ${IMAGE_VALIDATION_CONFIG.SUPPORTED_FORMATS.join(', ')}` 
    };
  }
  const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
  if (!base64Regex.test(data)) {
    return { isValid: false, error: 'Invalid base64 encoding' };
  }
  return { isValid: true, format, data };
}
/**
 * Validates image file size
 */
export function validateImageSize(base64Data: string): { isValid: boolean; error?: string; sizeBytes?: number } {
  const sizeBytes = Math.floor((base64Data.length * 3) / 4);
  if (sizeBytes < IMAGE_VALIDATION_CONFIG.MIN_FILE_SIZE) {
    return { 
      isValid: false, 
      error: `Image too small (minimum ${IMAGE_VALIDATION_CONFIG.MIN_FILE_SIZE} bytes)`,
      sizeBytes 
    };
  }
  if (sizeBytes > IMAGE_VALIDATION_CONFIG.MAX_FILE_SIZE) {
    return { 
      isValid: false, 
      error: `Image too large (maximum ${IMAGE_VALIDATION_CONFIG.MAX_FILE_SIZE} bytes)`,
      sizeBytes 
    };
  }
  return { isValid: true, sizeBytes };
}
/**
 * Scans for malicious patterns in the data
 */
export function scanForMaliciousPatterns(data: string): { isSafe: boolean; patterns?: string[] } {
  if (!IMAGE_VALIDATION_CONFIG.SCAN_FOR_MALICIOUS_PATTERNS) {
    return { isSafe: true };
  }
  const detectedPatterns: string[] = [];
  const lowerData = data.toLowerCase();
  for (const pattern of MALICIOUS_PATTERNS) {
    if (pattern.test(lowerData)) {
      detectedPatterns.push(pattern.source);
    }
  }
  if (detectedPatterns.length > 0) {
    return { isSafe: false, patterns: detectedPatterns };
  }
  return { isSafe: true };
}
/**
 * Validates image signature (magic number) and ensures the claimed format matches the buffer
 */
export async function validateImageSignature(buffer: Buffer, format: string): Promise<{ isValid: boolean; error?: string; detectedFormat?: string; mimeType?: string }> {
  if (!IMAGE_VALIDATION_CONFIG.REQUIRE_VALID_IMAGE_HEADERS) {
    return { isValid: true };
  }
  const fileType = await detectImageType(buffer);
  if (!fileType) {
    return { isValid: false, error: 'Could not detect image format from buffer' };
  }
  const detectedFormat = fileType.ext.toLowerCase();
  if (!IMAGE_VALIDATION_CONFIG.SUPPORTED_FORMATS.includes(detectedFormat as any)) {
    return {
      isValid: false,
      error: `Detected image format ${detectedFormat} is not supported`
    };
  }
  if (format && format.toLowerCase() !== detectedFormat) {
    return {
      isValid: false,
      error: `Declared format ${format} does not match actual format ${detectedFormat}`,
      detectedFormat,
      mimeType: fileType.mime
    };
  }
  const normalizedMime = IMAGE_VALIDATION_CONFIG.ALLOWED_MIME_TYPES.includes(fileType.mime as any)
    ? fileType.mime
    : `image/${detectedFormat}`;
  return {
    isValid: true,
    detectedFormat,
    mimeType: normalizedMime
  };
}
/**
 * Detects the image file type via `file-type`, falling back to manual magic-byte checks.
 */
async function detectImageType(buffer: Buffer): Promise<{ ext: string; mime: string } | null> {
  try {
    const fileType = await fileTypeFromBuffer(buffer);
    if (fileType) {
      const ext = fileType.ext.toLowerCase();
      if (IMAGE_VALIDATION_CONFIG.SUPPORTED_FORMATS.includes(ext as any)) {
        return { ext, mime: fileType.mime };
      }
    }
  } catch {
    // Continue to fallback detection when file-type fails
  }
  if (buffer.length >= 2 && buffer[0] === 0xff && buffer[1] === 0xd8) {
    return { ext: 'jpeg', mime: 'image/jpeg' };
  }
  if (
    buffer.length >= 8 &&
    buffer[0] === 0x89 &&
    buffer[1] === 0x50 &&
    buffer[2] === 0x4e &&
    buffer[3] === 0x47 &&
    buffer[4] === 0x0d &&
    buffer[5] === 0x0a &&
    buffer[6] === 0x1a &&
    buffer[7] === 0x0a
  ) {
    return { ext: 'png', mime: 'image/png' };
  }
  if (
    buffer.length >= 12 &&
    buffer.readUInt32BE(0) === 0x52494646 && // 'RIFF'
    buffer.readUInt32BE(8) === 0x57454250 // 'WEBP'
  ) {
    return { ext: 'webp', mime: 'image/webp' };
  }
  return null;
}
/**
 * Validates image dimensions to guard against oversized uploads
 */
export async function validateImageDimensions(buffer: Buffer): Promise<{ isValid: boolean; error?: string; width?: number; height?: number }> {
  try {
    const image = await Jimp.read(buffer);
    const { width, height } = image.bitmap;
    if (width > IMAGE_VALIDATION_CONFIG.MAX_DIMENSION || height > IMAGE_VALIDATION_CONFIG.MAX_DIMENSION) {
      return {
        isValid: false,
        error: `Image dimensions exceed maximum allowed size (${IMAGE_VALIDATION_CONFIG.MAX_DIMENSION}px)`
      };
    }
    return { isValid: true, width, height };
  } catch (error) {
    return {
      isValid: false,
      error: `Image decoding failed: ${error instanceof Error ? error.message : 'unknown error'}`
    };
  }
}
/**
 * Comprehensive image validation sequence
 */
export async function validateImage(base64Image: string): Promise<{
  isValid: boolean;
  error?: string;
  metadata?: {
    format: string;
    sizeBytes: number;
    mimeType: string;
    signature: string;
    dimensions?: { width?: number; height?: number };
  };
}> {
  try {
    const base64Validation = validateBase64Format(base64Image);
    if (!base64Validation.isValid) {
      return { isValid: false, error: base64Validation.error };
    }
    const { format, data } = base64Validation;
    if (!format || !data) {
      return { isValid: false, error: 'Invalid base64 format: missing format or data' };
    }
    const sizeValidation = validateImageSize(data);
    if (!sizeValidation.isValid) {
      return { isValid: false, error: sizeValidation.error };
    }
    const maliciousScan = scanForMaliciousPatterns(data);
    if (!maliciousScan.isSafe) {
      return { 
        isValid: false, 
        error: `Malicious patterns detected: ${maliciousScan.patterns?.join(', ')}` 
      };
    }
    const imageBuffer = Buffer.from(data, 'base64');
    const signatureValidation = await validateImageSignature(imageBuffer, format);
    if (!signatureValidation.isValid) {
      return { isValid: false, error: signatureValidation.error };
    }
    const dimensionValidation = await validateImageDimensions(imageBuffer);
    if (!dimensionValidation.isValid) {
      return { isValid: false, error: dimensionValidation.error };
    }
    const metadata = {
      format: signatureValidation.detectedFormat ?? format,
      sizeBytes: sizeValidation.sizeBytes!,
      mimeType: signatureValidation.mimeType ?? `image/${format}`,
      signature: createHash('sha256').update(imageBuffer).digest('hex'),
      dimensions: dimensionValidation.width && dimensionValidation.height 
        ? { width: dimensionValidation.width, height: dimensionValidation.height } 
        : undefined
    };
    return { isValid: true, metadata };
  } catch (error) {
    console.error('Image validation error:', error);
    return { 
      isValid: false, 
      error: 'Image validation failed due to processing error' 
    };
  }
}
/**
 * Zod schema for image validation
 */
export function createImageValidationSchema() {
  const { z } = require('zod');
  
  return z.string().min(IMAGE_VALIDATION_CONFIG.BASE64_MIN_LENGTH, {
    message: `Image must be at least ${IMAGE_VALIDATION_CONFIG.BASE64_MIN_LENGTH} characters long`
  }).max(IMAGE_VALIDATION_CONFIG.BASE64_MAX_LENGTH, {
    message: `Image must not exceed ${IMAGE_VALIDATION_CONFIG.BASE64_MAX_LENGTH} characters`
  }).regex(/^data:image\/(jpeg|jpg|png|webp);base64,[A-Za-z0-9+/]*={0,2}$/, {
    message: 'Invalid image format. Supported formats: JPEG, PNG, WebP'
  });
}
export default {
  validateImage,
  validateBase64Format,
  validateImageSize,
  scanForMaliciousPatterns,
  validateImageSignature,
  validateImageDimensions,
  createImageValidationSchema,
  IMAGE_VALIDATION_CONFIG
};