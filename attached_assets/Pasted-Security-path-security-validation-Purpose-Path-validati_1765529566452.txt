Security
@path-security/validation
Purpose: Path validation and sanitization against directory traversal attacks for file operations. Explanation:
This is a comprehensive security utility that validates and sanitizes file paths to prevent directory traversal attacks. It solves the critical security problem of path traversal vulnerabilities where malicious users could access files outside intended directories. The system implements multiple layers of validation including dangerous pattern detection, path normalization, length limits, and character filtering to ensure all file operations are secure.

Key features include comprehensive path traversal pattern detection, normalization using Node.js path utilities, validation against GCS/S3 naming rules for object storage, bucket name validation according to cloud storage standards, and detailed error reporting. The utility is framework-agnostic and can be used in any Node.js application that handles file operations, making it essential for secure file handling in web applications, cloud storage systems, and any application dealing with user-provided paths.

import path from 'path';
/**
 * Security utilities for path validation and sanitization
 * Implements comprehensive protection against path traversal attacks
 */
/**
 * Validates and sanitizes a file path to prevent directory traversal attacks
 * @param inputPath The raw input path to validate
 * @returns Normalized and safe path
 * @throws {Error} If path is invalid or contains traversal patterns
 */
export function validateAndNormalizePath(inputPath: string): string {
  if (!inputPath || typeof inputPath !== 'string') {
    throw new Error('Invalid path: must be a non-empty string');
  }
  // Remove null bytes and control characters
  const sanitizedPath = inputPath.replace(/[\x00-\x1F\x7F]/g, '');
  // Check for dangerous traversal patterns
  const dangerousPatterns = [
    /\.\./g,           // Parent directory traversal
    /\\/g,             // Windows path separators
    /\//,               // Multiple forward slashes (will be normalized)
    /^[/\\]/,           // Leading slashes
    /[\/\\]$/,         // Trailing slashes
  ];
  if (dangerousPatterns[0].test(sanitizedPath) || 
      dangerousPatterns[1].test(sanitizedPath)) {
    throw new Error('Path contains dangerous traversal patterns');
  }
  // Normalize path using Node's path utilities
  const normalizedPath = path.normalize(sanitizedPath);
  // Additional validation after normalization
  if (normalizedPath.includes('..') || 
      normalizedPath.includes('\\') || 
      normalizedPath.includes('\0')) {
    throw new Error('Normalized path contains dangerous characters');
  }
  // Ensure path doesn't start with traversal
  if (normalizedPath.startsWith('../') || normalizedPath.startsWith('..\\')) {
    throw new Error('Path attempts directory traversal');
  }
  // Limit path length to prevent buffer overflow attacks
  if (normalizedPath.length > 512) {
    throw new Error('Path too long: maximum 512 characters allowed');
  }
  return normalizedPath;
}
/**
 * Validates bucket name according to GCS/S3 naming rules
 * @param bucketName The bucket name to validate
 * @throws {Error} If bucket name is invalid
 */
export function validateBucketName(bucketName: string): void {
  if (!bucketName || typeof bucketName !== 'string') {
    throw new Error('Invalid bucket name: must be a non-empty string');
  }
  // GCS/S3 bucket name validation rules
  const bucketNamePattern = /^[a-z0-9][a-z0-9._-]{1,61}[a-z0-9]$/;
  if (!bucketNamePattern.test(bucketName)) {
    throw new Error(`Invalid bucket name: "${bucketName}" does not conform to naming rules`);
  }
  // Additional prohibited patterns
  const prohibitedPatterns = [
    /^\./,           // Cannot start with period
    /\.$/,           // Cannot end with period
    /\.\./,          // Cannot contain consecutive periods
    /^-/,           // Cannot start with hyphen
    /-$/,           // Cannot end with hyphen
    /\.{2,}/,       // Cannot have consecutive periods
    /^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/  // Cannot be IP address format
  ];
  for (const pattern of prohibitedPatterns) {
    if (pattern.test(bucketName)) {
      throw new Error(`Bucket name contains prohibited pattern: "${bucketName}"`);
    }
  }
  // Length validation
  if (bucketName.length < 3 || bucketName.length > 63) {
    throw new Error('Bucket name must be between 3 and 63 characters');
  }
}
/**
 * Validates object name according to GCS/S3 rules
 * @param objectName The object name to validate
 * @throws {Error} If object name is invalid
 */
export function validateObjectName(objectName: string): void {
  if (!objectName || typeof objectName !== 'string') {
    throw new Error('Invalid object name: must be a non-empty string');
  }
  // Size limits
  if (objectName.length > 1024) {
    throw new Error('Object name too long: maximum 1024 characters allowed');
  }
  // Disallowed characters and patterns
  const disallowedPatterns = [
    /\x00-\x1F/,     // Control characters
    /[\x7F-\x9F]/,    // High ASCII control characters
    /\r|\n/,           // Newline characters
  ];
  for (const pattern of disallowedPatterns) {
    if (pattern.test(objectName)) {
      throw new Error('Object name contains disallowed characters');
    }
  }
  // Specific prohibited values (GCS restrictions)
  const prohibitedNames = [
    '.', '..', '', 'CON', 'PRN', 'AUX', 'NUL',
    'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9',
    'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9'
  ];
  if (prohibitedNames.includes(objectName.toUpperCase())) {
    throw new Error(`Object name cannot be "${objectName}"`);
  }
}
/**
 * Creates a safe object path by combining bucket and object names
 * @param bucketName Validated bucket name
 * @param objectName Validated object name
 * @returns Safe combined path
 */
export function createSafeObjectPath(bucketName: string, objectName: string): string {
  validateBucketName(bucketName);
  validateObjectName(objectName);
  
  const safeObjectPath = validateAndNormalizePath(objectName);
  return `/${bucketName}/${safeObjectPath}`;
}

@secure-logging/sanitization
Purpose: Secure logging utilities that prevent sensitive data exposure in application logs. Explanation:
This is a comprehensive logging security system that sanitizes logs to prevent sensitive data exposure. It solves the critical security problem of accidentally logging sensitive information like passwords, tokens, API keys, and other credentials. The system implements pattern-based detection of sensitive data, field-level redaction, JWT token detection, URL sanitization, and safe logging context creation.

Key features include comprehensive sensitive data pattern detection, automatic redaction of common sensitive fields, JWT token recognition and masking, URL parameter sanitization to remove sensitive query parameters, safe response data logging that limits exposed information, and configurable field masking with partial visibility for debugging. The utility is framework-agnostic but includes Express-specific helpers, making it essential for any application that needs secure logging practices.

import { type Request } from 'express';
/**
 * Secure logging utilities that prevent sensitive data exposure
 * Implements data sanitization for logs and prevents information disclosure
 */
// Patterns that typically indicate sensitive data
const SENSITIVE_PATTERNS = [
  /password/i,
  /secret/i,
  /token/i,
  /key/i,
  /auth/i,
  /credential/i,
  /ssn/i,
  /credit.*card/i,
  /bank.*account/i,
];
/**
 * Fields that should always be redacted in logs
 */
const REDACTED_FIELDS = [
  'password',
  'secret', 
  'token',
  'apiKey',
  'authToken',
  'accessToken',
  'refreshToken',
  'idToken',
  'authorization',
  'cookie',
  'session',
  'csrf',
  'nonce',
  'signature',
  'hash',
  'salt',
];
/**
 * Sanitizes a value by redacting sensitive information
 * @param value The value to sanitize
 * @returns Sanitized string
 */
export function sanitizeLogValue(value: any): string {
  if (value === null || value === undefined) {
    return 'null';
  }
  if (typeof value === 'string') {
    // Check for sensitive patterns
    for (const pattern of SENSITIVE_PATTERNS) {
      if (pattern.test(value)) {
        return '[REDACTED_SENSITIVE]';
      }
    }
    
    // Check for potential JWT tokens (base64 with 3 parts)
    if (value.split('.').length === 3 && /^[A-Za-z0-9+/=]+$/.test(value)) {
      const parts = value.split('.');
      if (parts[0].length > 10 && parts[1].length > 10) {
        return '[REDACTED_TOKEN]';
      }
    }
    
    return value;
  }
  if (typeof value === 'object') {
    return sanitizeObject(value);
  }
  return String(value);
}
/**
 * Recursively sanitizes an object by redacting sensitive fields
 * @param obj The object to sanitize
 * @returns Sanitized object
 */
export function sanitizeObject(obj: any): any {
  if (obj === null || obj === undefined) {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map(sanitizeObject);
  }
  if (typeof obj === 'object') {
    const sanitized: any = {};
    
    for (const [key, value] of Object.entries(obj)) {
      // Check if field should be redacted
      if (REDACTED_FIELDS.includes(key) || 
          REDACTED_FIELDS.some(field => key.toLowerCase().includes(field.toLowerCase()))) {
        sanitized[key] = '[REDACTED]';
        continue;
      }
      // Recursively sanitize nested objects
      sanitized[key] = sanitizeObject(value);
    }
    
    return sanitized;
  }
  return sanitizeLogValue(obj);
}
/**
 * Creates a safe logging context that excludes sensitive request data
 * @param req Express request object
 * @returns Safe logging context object
 */
export function createSafeLoggingContext(req: Request): Record<string, any> {
  const context: Record<string, any> = {
    method: req.method,
    url: sanitizeUrl(req.url),
    userAgent: req.get('User-Agent'),
    ip: req.ip || req.connection?.remoteAddress,
    timestamp: new Date().toISOString(),
  };
  // Add select headers (excluding sensitive ones)
  const allowedHeaders = ['content-type', 'accept', 'x-requested-with'];
  context.headers = {};
  
  for (const header of allowedHeaders) {
    const value = req.get(header);
    if (value) {
      context.headers[header] = value;
    }
  }
  // Add request ID if available
  if ((req as any).id) {
    context.requestId = (req as any).id;
  }
  return context;
}
/**
 * Sanitizes a URL by removing sensitive query parameters
 * @param url The URL to sanitize
 * @returns Sanitized URL
 */
export function sanitizeUrl(url: string): string {
  try {
    const urlObj = new URL(url, `http://localhost`);
    
    // Remove sensitive query parameters
    const sensitiveParams = [
      'token', 'key', 'secret', 'password', 'auth',
      'apikey', 'access_token', 'refresh_token'
    ];
    
    sensitiveParams.forEach(param => {
      urlObj.searchParams.delete(param);
    });
    
    return urlObj.pathname + (urlObj.search || '');
  } catch {
    // If URL parsing fails, return a safe default
    return url.split('?')[0];
  }
}
/**
 * Sanitizes response data for logging
 * @param response The response object or data
 * @returns Sanitized response data
 */
export function sanitizeResponse(response: any): any {
  if (!response) {
    return response;
  }
  // For successful responses, limit what we log
  if (typeof response === 'object') {
    const sanitized: any = {
      status: response.status || 'success',
      timestamp: new Date().toISOString(),
    };
    // Add only non-sensitive metadata
    if (response.data) {
      sanitized.dataType = Array.isArray(response.data) ? 'array' : typeof response.data;
      
      if (response.data.message) {
        sanitized.message = response.data.message;
      }
      
      if (response.data.error) {
        sanitized.error = response.data.error;
      }
    }
    return sanitized;
  }
  return sanitizeLogValue(response);
}
/**
 * Determines if a field name suggests sensitive information
 * @param fieldName The field name to check
 * @returns True if field appears sensitive
 */
export function isSensitiveField(fieldName: string): boolean {
  const lowerFieldName = fieldName.toLowerCase();
  
  return REDACTED_FIELDS.includes(lowerFieldName) ||
         SENSITIVE_PATTERNS.some(pattern => pattern.test(lowerFieldName));
}
/**
 * Masks a string while preserving some characters for debugging
 * @param value The string to mask
 * @param visibleChars Number of characters to keep visible at start/end
 * @returns Masked string
 */
export function maskString(value: string, visibleChars: number = 4): string {
  if (value.length <= visibleChars * 2) {
    return '[REDACTED]';
  }
  
  const start = value.substring(0, visibleChars);
  const end = value.substring(value.length - visibleChars);
  const middle = '*'.repeat(value.length - (visibleChars * 2));
  
  return `${start}${middle}${end}`;
}