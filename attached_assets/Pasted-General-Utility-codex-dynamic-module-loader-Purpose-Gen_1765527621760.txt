General Utility
@codex/dynamic-module-loader
Purpose: Generic dynamic module loader that normalizes CommonJS/ESM interop. Explanation:
This module provides a universal solution for loading JavaScript modules dynamically while handling the complexities of CommonJS and ES Module interoperability. It solves the common problem of inconsistent module export shapes when using dynamic imports, particularly when dealing with packages that expose different export patterns. The loader automatically flattens default exports with named exports, providing a consistent interface regardless of the module's export structure.

The module is particularly useful in plugin architectures, optional dependency loading, testing environments, and microservice configurations where modules need to be loaded dynamically at runtime.

/**
 * Generic dynamic module loader that normalizes CommonJS/ESM interop.
 *
 * Many optional deps expose helpers on a default export when consumed via ESM
 * dynamic import, while others only provide named exports. This helper flattens
 * both shapes so callers can treat the returned value uniformly.
 *
 * Usage:
 *  - Prefer using specialized wrappers (e.g., loadQerrors, loadQgenutils) in
 *    app code. Those wrappers should delegate to this function.
 *
 * Error handling:
 *  - Returns null when the module cannot be loaded so callers can fall back.
 *
 * @param moduleName Name passed to dynamic import (e.g., `qerrors`)
 * @returns Flattened module namespace or null if unavailable
 */
export async function loadAndFlattenModule<T = Record<string, any>>(
  moduleName: string,
): Promise<T | null> {
  try {
    const namespace: any = await import(/* @vite-ignore */ moduleName);
    if (!namespace) {
      return null;
    }
    const def = namespace.default;
    if (def && typeof def === `object`) {
      // Combine default export helpers with named exports for CJS/ESM parity
      return { ...(def as object), ...(namespace as object) } as T;
    }
    // If only named exports exist, return them directly
    return namespace as T;
  } catch {
    return null;
  }
}
export default loadAndFlattenModule;

@codex/loader-factory
Purpose: Generic factory for creating cached async module loaders. Explanation:
This module provides a factory pattern for creating configurable module loaders with caching, error handling, and fallback mechanisms. It solves the problem of repeated module loading overhead and inconsistent error handling when dealing with optional dependencies. The factory creates loaders that can cache modules for performance, handle loading failures gracefully, and provide consistent fallback behavior.

The module is essential for applications that need to load optional dependencies, implement plugin architectures, or maintain performance while dynamically loading modules. It eliminates boilerplate code and provides a standardized approach to module loading across the application.

/**
 * Generic factory for creating cached async module loaders.
 *
 * Eliminates duplication across qerrorsLoader, qgenutilsLoader, and qapiLoader
 * by providing a configurable loader that handles caching, flattening, and error recovery.
 *
 * @template T - Expected return type of the loaded module
 */
import { loadAndFlattenModule } from './dynamicModuleLoader';
interface LoaderOptions<T = any> {
  /** Module name to dynamically import */
  moduleName: string;
  /** Whether to enable caching (default: true) */
  enableCache?: boolean;
  /** Custom flattening function (defaults to loadAndFlattenModule) */
  flattenFn?: (moduleName: string) => Promise<T>;
  /** Fallback value when module fails to load (default: null) */
  fallbackValue?: T;
  /** Log message when module is unavailable */
  unavailableMessage?: string;
}
/**
 * Creates a cached loader function for a given module.
 *
 * @param options - Configuration for the loader
 * @returns Async function that loads and caches the module
 */
export function createCachedLoader<T = any>(options: LoaderOptions<T>) {
  const {
    moduleName,
    enableCache = true,
    flattenFn = loadAndFlattenModule<T>,
    fallbackValue = null as T,
    unavailableMessage = `Module '${moduleName}' not available, using fallback`
  } = options;
  let cachedModule: T | null = null;
  let pendingLoad: Promise<T | null> | null = null;
  return async function loadModule(): Promise<T | null> {
    // Return cached instance if available and caching is enabled
    if (enableCache && cachedModule) {
      return cachedModule;
    }
    // Return existing pending promise to avoid concurrent loads
    if (enableCache && pendingLoad) {
      return pendingLoad;
    }
    // Create new load promise
    pendingLoad = (async () => {
      try {
        const module = await flattenFn(moduleName);
        if (enableCache) {
          cachedModule = module;
        }
        return module;
      } catch (error) {
        console.warn(unavailableMessage, error);
        pendingLoad = null;
        return fallbackValue;
      }
    })();
    return pendingLoad;
  };
}
/**
 * Creates a simple non-cached loader function.
 *
 * @param options - Configuration for the loader
 * @returns Async function that loads the module without caching
 */
export function createSimpleLoader<T = any>(options: Omit<LoaderOptions<T>, 'enableCache'>) {
  return createCachedLoader<T>({ ...options, enableCache: false });
}
/**
 * Creates a loader that uses dynamic import directly (no flattening).
 *
 * Useful for modules that don't need CJS/ESM interop handling.
 *
 * @param options - Configuration for the loader
 * @returns Async function that loads and caches the module
 */
export function createDirectLoader<T = any>(options: LoaderOptions<T>) {
  const flattenFn = async (moduleName: string): Promise<T> => {
    const mod = await import(moduleName);
    return mod?.default ?? mod;
  };
  return createCachedLoader<T>({ ...options, flattenFn });
}