System
@codex/security-middleware
Purpose: Comprehensive security middleware for Express applications with rate limiting and monitoring. Explanation:
This module provides essential security middleware functionality including rate limiting, request monitoring, suspicious pattern detection, and security headers. It solves the problem of implementing basic security measures in Express applications by offering a complete security suite that works with both Redis and in-memory storage. The middleware includes IP-based rate limiting, request size validation, XSS protection, and comprehensive security logging.

The module is particularly valuable for production applications that need robust security protection, APIs that require rate limiting and monitoring, and applications that need to defend against common web attacks while maintaining performance.

/**
 * Security Middleware Implementation
 * 
 * Provides essential security middleware functionality as an alternative
 * to the disabled qapinterface security monitoring middleware.
 * 
 * Security Features:
 * - Request logging for security monitoring
 * - IP-based rate limiting and tracking
 * - Suspicious request pattern detection
 * - Security event logging and alerting
 */
import type { Request, Response, NextFunction } from 'express';
import rateLimit, {
  type RateLimitExceededEventHandler,
  type RateLimitRequestHandler,
  type Store
} from 'express-rate-limit';
// Security configuration
export const SECURITY_CONFIG = {
  // Rate limiting per IP
  RATE_LIMIT_WINDOW_MS: 15 * 60 * 1000, // 15 minutes
  RATE_LIMIT_MAX_REQUESTS: 100, // 100 requests per window
  
  // Suspicious pattern detection
  MAX_REQUEST_SIZE: 50 * 1024 * 1024, // 50MB
  MAX_URL_LENGTH: 2048,
  
  // Security monitoring
  LOG_ALL_REQUESTS: true,
  SENSITIVE_ENDPOINTS: ['/api/faceqrop'],
  
  // IP blocking
  MAX_FAILED_ATTEMPTS: 10,
  BLOCK_DURATION_MS: 30 * 60 * 1000 // 30 minutes
} as const;
// Redis-based distributed storage for rate limiting and security tracking
import Redis from 'ioredis';
// Redis client with fallback to in-memory for development
let redis: Redis | null = null;
let ipTracking = new Map<string, {
  requestCount: number;
  windowStart: number;
  lastRequest: number;
  failedAttempts: number;
  blockedUntil: number;
  suspiciousPatterns: string[];
}>();
const blockedIps = new Map<string, number>();
const RATE_LIMIT_KEY_PREFIX = 'faceqrop:rate-limit:';
const resolveClientKey = (req: Request): string =>
  req.ip || req.socket?.remoteAddress || 'unknown';
// Memory management: limit the number of tracked IPs and cleanup interval
const MAX_TRACKED_IPS = 10000; // Prevent unbounded memory growth
let cleanupInterval: NodeJS.Timeout | null = null;
// Initialize Redis if available, otherwise fallback to in-memory
try {
  redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379', {
    maxRetriesPerRequest: 3,
    lazyConnect: true
  });
  
  redis.on('error', (err) => {
    console.warn('Redis connection failed, falling back to in-memory storage:', err.message);
    redis = null;
  });
  
  // Test connection
  redis.connect().catch(() => {
    console.warn('Redis not available, using in-memory fallback');
    redis = null;
  });
} catch (error) {
  console.warn('Redis initialization failed, using in-memory fallback:', error);
  redis = null;
}
// Start periodic cleanup for memory management
startPeriodicCleanup();
/**
 * Enhanced cleanup with memory bounds to prevent unbounded growth
 */
function cleanupExpiredEntries(): void {
  const now = Date.now();
  const entriesToDelete: string[] = [];
  
  ipTracking.forEach((data, ip) => {
    // ðŸš€ SCALABILITY: Enhanced cleanup with memory bounds and suspiciousPatterns truncation
    if (data.windowStart + SECURITY_CONFIG.RATE_LIMIT_WINDOW_MS < now &&
        data.blockedUntil < now) {
      entriesToDelete.push(ip);
    } else {
      // Truncate suspiciousPatterns for active entries to prevent memory growth
      if (data.suspiciousPatterns.length > 10) {
        data.suspiciousPatterns = data.suspiciousPatterns.slice(-5); // Keep only recent 5
      }
    }
  });
  
  blockedIps.forEach((expires, key) => {
    if (expires <= now) {
      blockedIps.delete(key);
    }
  });
  entriesToDelete.forEach(ip => ipTracking.delete(ip));
  
  // Memory protection: remove oldest entries if we exceed max tracked IPs
  if (ipTracking.size > MAX_TRACKED_IPS) {
    const sortedEntries = Array.from(ipTracking.entries())
      .sort(([, a], [, b]) => a.lastRequest - b.lastRequest);
    
    const entriesToRemove = sortedEntries.slice(0, ipTracking.size - MAX_TRACKED_IPS);
    entriesToRemove.forEach(([ip]) => ipTracking.delete(ip));
    
    console.warn(`IP tracking cleanup: removed ${entriesToRemove.length} oldest entries to prevent memory exhaustion`);
  }
  
  // ðŸš€ SCALABILITY: Force memory cleanup if tracking grows too large
  if (ipTracking.size > MAX_TRACKED_IPS * 0.8) {
    const totalPatterns = Array.from(ipTracking.values())
      .reduce((sum, data) => sum + data.suspiciousPatterns.length, 0);
    
    if (totalPatterns > ipTracking.size * 15) { // Average > 15 patterns per IP
      console.warn(`High suspiciousPatterns memory usage detected, forcing aggressive cleanup`);
      ipTracking.forEach((data) => {
        if (data.suspiciousPatterns.length > 5) {
          data.suspiciousPatterns = data.suspiciousPatterns.slice(-3);
        }
      });
    }
  }
}
/**
 * Start periodic cleanup to prevent memory leaks
 */
function startPeriodicCleanup(): void {
  if (cleanupInterval) return;
  
  cleanupInterval = setInterval(() => {
    cleanupExpiredEntries();
  }, 5 * 60 * 1000); // Every 5 minutes
}
/**
 * Stop periodic cleanup
 */
function stopPeriodicCleanup(): void {
  if (cleanupInterval) {
    clearInterval(cleanupInterval);
    cleanupInterval = null;
  }
}
/**
 * Security monitoring middleware with Redis-based distributed rate limiting
 * Logs requests and detects suspicious patterns
 */
export async function securityMonitoringMiddleware(req: Request, res: Response, next: NextFunction): Promise<void> {
  const clientIp = req.ip || req.socket?.remoteAddress || 'unknown';
  const now = Date.now();
  if (Math.random() < 0.01) {
    cleanupExpiredEntries();
  }
  // Detect suspicious patterns
  const suspiciousPatterns: string[] = [];
  
  // Check for unusually large requests
  const contentLength = parseInt(req.headers['content-length'] || '0');
  if (contentLength > SECURITY_CONFIG.MAX_REQUEST_SIZE) {
    suspiciousPatterns.push('oversized_request');
  }
  
  // Check for unusually long URLs
  if (req.url.length > SECURITY_CONFIG.MAX_URL_LENGTH) {
    suspiciousPatterns.push('long_url');
  }
  
  // Check for common attack patterns in URL (optimized for performance)
  // Use a single combined regex to avoid multiple pattern tests
  const urlLower = req.url.toLowerCase();
  if (/\.\./.test(req.url) || 
      /<script/i.test(req.url) || 
      urlLower.includes('javascript:') || 
      urlLower.includes('data:') || 
      urlLower.includes('vbscript:')) {
    suspiciousPatterns.push('potential_xss');
  }
  
  // Log suspicious activity
  if (suspiciousPatterns.length > 0) {
    console.warn(`Suspicious activity from IP ${clientIp}:`, {
      url: req.url,
      method: req.method,
      patterns: suspiciousPatterns,
      userAgent: req.headers['user-agent']
    });
    
    // For Redis mode, we'd need to track suspicious patterns separately
    // For now, just log them
    if (redis) {
      try {
        const suspiciousKey = `suspicious:${clientIp}`;
        await redis.incr(suspiciousKey);
        await redis.expire(suspiciousKey, Math.ceil(SECURITY_CONFIG.BLOCK_DURATION_MS / 1000));
      } catch (error) {
        console.warn('Failed to log suspicious activity to Redis:', error);
      }
    } else {
      // In-memory fallback for suspicious patterns
      let ipData = ipTracking.get(clientIp);
      if (!ipData) {
        ipData = {
          requestCount: 0,
          windowStart: now,
          lastRequest: now,
          failedAttempts: 0,
          blockedUntil: 0,
          suspiciousPatterns: []
        };
        ipTracking.set(clientIp, ipData);
      }
      ipData.lastRequest = now;
      ipData.windowStart = now;
      
      // Memory protection: limit suspicious patterns array size
      ipData.suspiciousPatterns.push(...suspiciousPatterns);
      if (ipData.suspiciousPatterns.length > 50) { // Prevent unbounded array growth
        ipData.suspiciousPatterns = ipData.suspiciousPatterns.slice(-25); // Keep only recent 25
      }
      
      ipData.failedAttempts++;
      
      // Block if too many suspicious patterns
      if (ipData.failedAttempts >= SECURITY_CONFIG.MAX_FAILED_ATTEMPTS) {
        ipData.blockedUntil = now + SECURITY_CONFIG.BLOCK_DURATION_MS;
        
        console.warn(`IP ${clientIp} blocked due to repeated suspicious activity`);
        
        res.status(403).json({
          error: 'Forbidden',
          message: 'Access denied due to suspicious activity'
        });
        return;
      }
    }
  }
  
  // Log request for security monitoring
  if (SECURITY_CONFIG.LOG_ALL_REQUESTS || SECURITY_CONFIG.SENSITIVE_ENDPOINTS.some(endpoint => req.path.startsWith(endpoint))) {
    const logData = {
      ip: clientIp,
      method: req.method,
      url: req.url,
      userAgent: req.headers['user-agent'],
      timestamp: new Date().toISOString(),
      suspiciousPatterns: suspiciousPatterns.length > 0 ? suspiciousPatterns : undefined
    };
    
    console.log('Security Request Log:', JSON.stringify(logData));
  }
  
  next();
}
const RATE_LIMIT_WINDOW_MS = SECURITY_CONFIG.RATE_LIMIT_WINDOW_MS;
const RATE_LIMIT_MAX_REQUESTS = SECURITY_CONFIG.RATE_LIMIT_MAX_REQUESTS;
const BLOCK_DURATION_MS = SECURITY_CONFIG.BLOCK_DURATION_MS;
const rateLimitHandler: RateLimitExceededEventHandler = (req, res, _next, _options) => {
  const key = resolveClientKey(req);
  const blockUntil = Date.now() + BLOCK_DURATION_MS;
  blockedIps.set(key, blockUntil);
  const retryAfterSeconds = Math.ceil((blockUntil - Date.now()) / 1000);
  res.setHeader('Retry-After', retryAfterSeconds.toString());
  res.setHeader('X-RateLimit-Limit', RATE_LIMIT_MAX_REQUESTS.toString());
  res.setHeader('X-RateLimit-Remaining', '0');
  res.setHeader('X-RateLimit-Reset', new Date(blockUntil).toISOString());
  console.warn(`IP ${key} blocked by rate limiter until ${new Date(blockUntil).toISOString()}`);
  res.status(429).json({
    error: 'Too Many Requests',
    message: 'Rate limit exceeded',
    retryAfter: retryAfterSeconds
  });
};
class RedisRateLimitStore implements Store {
  readonly localKeys = false;
  constructor(
    private readonly client: Redis,
    private readonly windowMs: number,
    readonly prefix: string,
  ) {}
  private redisKey(key: string) {
    return `${this.prefix}${key}`;
  }
  private buildResetTime(ttl: number) {
    if (ttl > 0) {
      return new Date(Date.now() + ttl);
    }
    return new Date(Date.now() + this.windowMs);
  }
  async get(key: string) {
    const redisKey = this.redisKey(key);
    const hits = await this.client.get(redisKey);
    if (!hits) {
      return undefined;
    }
    const totalHits = Number(hits);
    if (!Number.isFinite(totalHits)) {
      return undefined;
    }
    const ttl = await this.client.pttl(redisKey);
    return {
      totalHits,
      resetTime: this.buildResetTime(ttl),
    };
  }
  async increment(key: string) {
    const redisKey = this.redisKey(key);
    const totalHits = await this.client.incr(redisKey);
    if (totalHits === 1) {
      await this.client.pexpire(redisKey, this.windowMs);
    }
    const ttl = await this.client.pttl(redisKey);
    return {
      totalHits,
      resetTime: this.buildResetTime(ttl),
    };
  }
  async decrement(key: string) {
    const redisKey = this.redisKey(key);
    await this.client.decr(redisKey);
  }
  async resetKey(key: string) {
    await this.client.del(this.redisKey(key));
  }
}
function createRateLimiter(store?: Store): RateLimitRequestHandler {
  return rateLimit({
    windowMs: RATE_LIMIT_WINDOW_MS,
    limit: RATE_LIMIT_MAX_REQUESTS,
    statusCode: 429,
    standardHeaders: true,
    legacyHeaders: true,
    handler: rateLimitHandler,
    keyGenerator: resolveClientKey,
    requestPropertyName: 'rateLimit',
    store,
    skipFailedRequests: false,
    skipSuccessfulRequests: false,
  });
}
const memoryRateLimiter = createRateLimiter();
let redisRateLimiter: RateLimitRequestHandler | null = null;
function getRateLimiter(): RateLimitRequestHandler {
  if (redis) {
    if (!redisRateLimiter) {
      redisRateLimiter = createRateLimiter(new RedisRateLimitStore(redis, RATE_LIMIT_WINDOW_MS, RATE_LIMIT_KEY_PREFIX));
    }
    return redisRateLimiter;
  }
  redisRateLimiter = null;
  return memoryRateLimiter;
}
export function rateLimitingMiddleware(req: Request, res: Response, next: NextFunction): void {
  const now = Date.now();
  const clientKey = resolveClientKey(req);
  const blockUntil = blockedIps.get(clientKey);
  if (blockUntil && blockUntil > now) {
    const retryAfterSeconds = Math.ceil((blockUntil - now) / 1000);
    res.setHeader('Retry-After', retryAfterSeconds.toString());
    res.setHeader('X-RateLimit-Limit', RATE_LIMIT_MAX_REQUESTS.toString());
    res.setHeader('X-RateLimit-Remaining', '0');
    res.setHeader('X-RateLimit-Reset', new Date(blockUntil).toISOString());
    res.status(429).json({
      error: 'Too Many Requests',
      message: 'Rate limit exceeded',
      retryAfter: retryAfterSeconds
    });
    return;
  }
  if (blockUntil) {
    blockedIps.delete(clientKey);
  }
  const limiter = getRateLimiter();
  return limiter(req, res, next);
}
/**
 * Request size limiting middleware
 * Prevents denial of service attacks from oversized requests
 */
export async function requestSizeLimitMiddleware(req: Request, res: Response, next: NextFunction): Promise<void> {
  const contentLength = parseInt(req.headers['content-length'] || '0');
  
  if (contentLength > SECURITY_CONFIG.MAX_REQUEST_SIZE) {
    console.warn(`Oversized request rejected: ${contentLength} bytes from IP ${req.ip}`);
    
    res.status(413).json({
      error: 'Payload Too Large',
      message: `Request size ${contentLength} exceeds maximum allowed size of ${SECURITY_CONFIG.MAX_REQUEST_SIZE} bytes`
    });
    return;
  }
  
  next();
}
/**
 * Security headers middleware
 * Adds essential security headers to responses
 */
export async function securityHeadersMiddleware(req: Request, res: Response, next: NextFunction): Promise<void> {
  // Content Security Policy
  res.setHeader('Content-Security-Policy', 
    "default-src 'self'; " +
    "script-src 'self' 'unsafe-inline'; " +
    "style-src 'self' 'unsafe-inline'; " +
    "img-src 'self' data: blob:; " +
    "font-src 'self'; " +
    "connect-src 'self'; " +
    "frame-ancestors 'none'; " +
    "base-uri 'self'; " +
    "form-action 'self'"
  );
  
  // Other security headers
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
  res.setHeader('Permissions-Policy', 'camera=(), microphone=(), geolocation=()');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
  
  next();
}
// Graceful cleanup on process exit
process.on('SIGTERM', () => {
  stopPeriodicCleanup();
  ipTracking.clear();
});
process.on('SIGINT', () => {
  stopPeriodicCleanup();
  ipTracking.clear();
});
export function __setBlockedIpForTest(ip: string, expiresAt: number): void {
  blockedIps.set(ip, expiresAt);
}
export function __clearBlockedIpsForTest(): void {
  blockedIps.clear();
}
export default {
  securityMonitoringMiddleware,
  rateLimitingMiddleware,
  requestSizeLimitMiddleware,
  securityHeadersMiddleware,
  SECURITY_CONFIG,
  cleanupExpiredEntries,
  stopPeriodicCleanup,
  __setBlockedIpForTest,
  __clearBlockedIpsForTest,
};