System
@scrooge/interval-helpers
Purpose: Comprehensive scheduling and interval management utilities for Node.js applications. Explanation:
This module provides utilities for converting milliseconds to cron expressions, scheduling intervals with job tracking, and managing bulk interval cleanup. It solves the problem of time-based job scheduling and cleanup in Node.js applications by providing consistent interfaces and tracking mechanisms. This would be reused across any Node.js application that needs scheduled tasks, background jobs, or time-based operations, particularly in microservices and data processing pipelines.

The module accepts time values in milliseconds, functions to execute, and optional identifiers, returning scheduled jobs and management utilities. It handles edge cases like invalid time values, job tracking, and comprehensive cleanup operations.

/**
 * Interval Helpers Utilities
 * Provides comprehensive scheduling and interval management capabilities
 */
const nodeSchedule = require('node-schedule');
const { qerrors } = require('../offlineMode/index.js');
/**
 * Convert milliseconds to cron expression
 * @param {number} ms - Milliseconds to convert
 * @returns {string} Cron expression
 */
function msToCron(ms) {
  if (typeof ms !== 'number' || ms <= 0) {
    throw new Error('Milliseconds must be a positive number');
  }
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  if (seconds < 60) {
    return `*/${seconds} * * * * *`;
  } else if (minutes < 60) {
    return `0 */${minutes} * * * *`;
  } else if (hours < 24) {
    return `0 0 */${hours} * * *`;
  } else {
    return `0 0 0 */${days} * *`;
  }
}
/**
 * Schedule an interval with job tracking
 * @param {Function} callback - Function to execute
 * @param {number} intervalMs - Interval in milliseconds
 * @param {Object} options - Scheduling options
 * @returns {Object} Job object with cancel method
 */
function scheduleInterval(callback, intervalMs, options = {}) {
  const { 
    identifier = null, 
    immediate = false, 
    maxExecutions = null,
    onError = null 
  } = options;
  if (typeof callback !== 'function') {
    throw new Error('Callback must be a function');
  }
  if (typeof intervalMs !== 'number' || intervalMs <= 0) {
    throw new Error('Interval must be a positive number');
  }
  let executionCount = 0;
  let jobId = null;
  const executeCallback = async () => {
    try {
      executionCount++;
      
      // Check if we've reached max executions
      if (maxExecutions !== null && executionCount >= maxExecutions) {
        if (jobId) {
          nodeSchedule.cancelJob(jobId);
        }
        return;
      }
      // Execute the callback
      await callback();
    } catch (error) {
      qerrors(error, 'Interval execution error', {
        identifier,
        executionCount,
        intervalMs
      });
      if (onError && typeof onError === 'function') {
        onError(error);
      }
    }
  };
  // Create cron expression from milliseconds
  const cronExpression = msToCron(intervalMs);
  
  // Schedule the job
  const job = nodeSchedule.scheduleJob(cronExpression, executeCallback);
  
  if (!job) {
    throw new Error('Failed to schedule interval job');
  }
  jobId = identifier || job.name || 'interval_' + Date.now();
  // Execute immediately if requested
  if (immediate) {
    setImmediate(executeCallback);
  }
  return {
    id: jobId,
    cancel: () => {
      if (job) {
        nodeSchedule.cancelJob(job);
        return true;
      }
      return false;
    },
    isRunning: () => {
      return job && !job.cancelled;
    },
    getExecutionCount: () => executionCount
  };
}
/**
 * Schedule a one-time job
 * @param {Function} callback - Function to execute
 * @param {Date|number} when - When to execute (Date or timestamp)
 * @param {Object} options - Scheduling options
 * @returns {Object} Job object with cancel method
 */
function scheduleOnce(callback, when, options = {}) {
  const { identifier = null, onError = null } = options;
  if (typeof callback !== 'function') {
    throw new Error('Callback must be a function');
  }
  let executionDate = when;
  if (typeof when === 'number') {
    executionDate = new Date(when);
  }
  if (!(executionDate instanceof Date) || isNaN(executionDate.getTime())) {
    throw new Error('When must be a valid Date or timestamp');
  }
  const executeCallback = async () => {
    try {
      await callback();
    } catch (error) {
      qerrors(error, 'Scheduled job execution error', {
        identifier,
        scheduledFor: executionDate
      });
      if (onError && typeof onError === 'function') {
        onError(error);
      }
    }
  };
  const job = nodeSchedule.scheduleJob(executionDate, executeCallback);
  
  if (!job) {
    throw new Error('Failed to schedule job');
  }
  return {
    id: identifier || job.name || 'job_' + Date.now(),
    cancel: () => {
      if (job) {
        nodeSchedule.cancelJob(job);
        return true;
      }
      return false;
    },
    isRunning: () => {
      return job && !job.cancelled;
    },
    getScheduledFor: () => executionDate
  };
}
/**
 * Bulk cleanup of scheduled jobs
 * @param {Array} jobs - Array of job objects from scheduleInterval/scheduleOnce
 * @returns {number} Number of jobs cancelled
 */
function cleanupJobs(jobs) {
  if (!Array.isArray(jobs)) {
    throw new Error('Jobs must be an array');
  }
  let cancelledCount = 0;
  jobs.forEach(job => {
    try {
      if (job && typeof job.cancel === 'function') {
        if (job.cancel()) {
          cancelledCount++;
        }
      }
    } catch (error) {
      qerrors(error, 'Job cleanup error', { job });
    }
  });
  return cancelledCount;
}
module.exports = {
  msToCron,
  scheduleInterval,
  scheduleOnce,
  cleanupJobs
};

@scrooge/config-builder
Purpose: Comprehensive configuration building utilities for feature flags, security settings, and validation configurations. Explanation:
This module provides a suite of configuration builders that standardize the creation of feature flags, security configurations, validation settings, and performance metrics. It solves the problem of inconsistent configuration patterns across applications by providing standardized builders with type safety and validation. This would be reused across any Node.js application that needs structured configuration management, particularly in microservices and enterprise applications.

The module accepts configuration options and returns structured configuration objects with validation and defaults. It handles edge cases like invalid inputs, missing required fields, and provides comprehensive configuration merging capabilities.

/**
 * Configuration Builder Utilities
 * Provides standardized configuration builders for various application needs
 */
/**
 * Build feature configuration with validation and defaults
 * @param {Object} options - Feature configuration options
 * @returns {Object} Validated feature configuration
 */
function buildFeatureConfig(options = {}) {
  const {
    name = '',
    enabled = false,
    version = '1.0.0',
    environment = 'development',
    dependencies = [],
    metadata = {},
    rolloutPercentage = 100,
    conditions = {}
  } = options;
  if (!name || typeof name !== 'string') {
    throw new Error('Feature name is required and must be a string');
  }
  if (typeof enabled !== 'boolean') {
    throw new Error('Feature enabled flag must be a boolean');
  }
  if (!Array.isArray(dependencies)) {
    throw new Error('Feature dependencies must be an array');
  }
  if (rolloutPercentage < 0 || rolloutPercentage > 100) {
    throw new Error('Rollout percentage must be between 0 and 100');
  }
  return {
    name: name.trim(),
    enabled,
    version,
    environment,
    dependencies: dependencies.map(dep => String(dep)),
    metadata: Object(metadata),
    rolloutPercentage,
    conditions,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };
}
/**
 * Build security configuration with comprehensive settings
 * @param {Object} options - Security configuration options
 * @returns {Object} Validated security configuration
 */
function buildSecurityConfig(options = {}) {
  const {
    encryptionEnabled = true,
    encryptionAlgorithm = 'aes-256-gcm',
    hashAlgorithm = 'sha256',
    sessionTimeout = 30 * 60 * 1000, // 30 minutes
    maxLoginAttempts = 5,
    lockoutDuration = 15 * 60 * 1000, // 15 minutes
    passwordMinLength = 8,
    passwordRequireUppercase = true,
    passwordRequireLowercase = true,
    passwordRequireNumbers = true,
    passwordRequireSpecialChars = true,
    jwtSecret = null,
    jwtExpiration = '1h',
    corsOrigins = ['*'],
    rateLimitEnabled = true,
    rateLimitWindowMs = 15 * 60 * 1000, // 15 minutes
    rateLimitMax = 100,
    headers = {
      'X-Content-Type-Options': 'nosniff',
      'X-Frame-Options': 'DENY',
      'X-XSS-Protection': '1; mode=block'
    }
  } = options;
  if (sessionTimeout <= 0) {
    throw new Error('Session timeout must be positive');
  }
  if (maxLoginAttempts <= 0) {
    throw new Error('Max login attempts must be positive');
  }
  if (passwordMinLength < 4) {
    throw new Error('Password minimum length must be at least 4');
  }
  return {
    encryption: {
      enabled: Boolean(encryptionEnabled),
      algorithm: String(encryptionAlgorithm),
      keyRotationEnabled: options.encryptionKeyRotationEnabled || false
    },
    hash: {
      algorithm: String(hashAlgorithm),
      iterations: options.hashIterations || 100000
    },
    authentication: {
      sessionTimeout: Number(sessionTimeout),
      maxLoginAttempts: Number(maxLoginAttempts),
      lockoutDuration: Number(lockoutDuration),
      passwordPolicy: {
        minLength: Number(passwordMinLength),
        requireUppercase: Boolean(passwordRequireUppercase),
        requireLowercase: Boolean(passwordRequireLowercase),
        requireNumbers: Boolean(passwordRequireNumbers),
        requireSpecialChars: Boolean(passwordRequireSpecialChars)
      }
    },
    jwt: {
      secret: jwtSecret,
      expiration: String(jwtExpiration),
      issuer: options.jwtIssuer || null,
      audience: options.jwtAudience || null
    },
    cors: {
      origins: Array.isArray(corsOrigins) ? corsOrigins : [String(corsOrigins)],
      credentials: options.corsCredentials || false,
      methods: options.corsMethods || ['GET', 'POST', 'PUT', 'DELETE'],
      allowedHeaders: options.corsAllowedHeaders || ['Content-Type', 'Authorization']
    },
    rateLimit: {
      enabled: Boolean(rateLimitEnabled),
      windowMs: Number(rateLimitWindowMs),
      max: Number(rateLimitMax),
      skipSuccessfulRequests: options.rateLimitSkipSuccessful || false,
      skipFailedRequests: options.rateLimitSkipFailed || false
    },
    headers: Object(headers),
    securityHeadersEnabled: options.securityHeadersEnabled !== false,
    httpsRedirect: options.httpsRedirect || false,
    trustProxy: options.trustProxy || false
  };
}
/**
 * Build validation configuration for data validation
 * @param {Object} options - Validation configuration options
 * @returns {Object} Validated validation configuration
 */
function buildValidationConfig(options = {}) {
  const {
    strictMode = true,
    sanitizeHtml = true,
    sanitizeXss = true,
    maxFieldLength = 1000,
    allowedTags = [],
    allowedAttributes = {},
    customValidators = {},
    errorMessages = {},
    localization = 'en'
  } = options;
  if (maxFieldLength <= 0) {
    throw new Error('Max field length must be positive');
  }
  return {
    strictMode: Boolean(strictMode),
    sanitization: {
      html: Boolean(sanitizeHtml),
      xss: Boolean(sanitizeXss),
      sqlInjection: options.sanitizeSqlInjection !== false,
      nosqlInjection: options.sanitizeNoSqlInjection || false
    },
    limits: {
      maxFieldLength: Number(maxFieldLength),
      maxFileSize: options.maxFileSize || 5 * 1024 * 1024, // 5MB
      maxArrayLength: options.maxArrayLength || 1000,
      maxObjectDepth: options.maxObjectDepth || 10
    },
    allowedContent: {
      htmlTags: Array.isArray(allowedTags) ? allowedTags : [],
      htmlAttributes: Object(allowedAttributes),
      fileTypes: options.allowedFileTypes || [],
      mimeTypes: options.allowedMimeTypes || []
    },
    customValidators: Object(customValidators),
    errorMessages: Object(errorMessages),
    localization: String(localization),
    dateFormat: options.dateFormat || 'YYYY-MM-DD',
    timezone: options.timezone || 'UTC'
  };
}
/**
 * Build test runner configuration
 * @param {Object} options - Test runner configuration options
 * @returns {Object} Validated test runner configuration
 */
function buildTestRunnerConfig(options = {}) {
  const {
    timeout = 5000,
    retries = 0,
    parallel = true,
    maxWorkers = 4,
    coverage = true,
    coverageThreshold = 80,
    testMatch = ['**/*.test.js', '**/*.spec.js'],
    testIgnore = ['node_modules', 'dist', 'build'],
    reporters = ['spec'],
    setupFiles = [],
    teardownFiles = [],
    environment = 'node',
    globals = {},
    verbose = false
  } = options;
  if (timeout <= 0) {
    throw new Error('Test timeout must be positive');
  }
  if (retries < 0) {
    throw new Error('Test retries cannot be negative');
  }
  if (maxWorkers <= 0) {
    throw new Error('Max workers must be positive');
  }
  return {
    execution: {
      timeout: Number(timeout),
      retries: Number(retries),
      parallel: Boolean(parallel),
      maxWorkers: Number(maxWorkers),
      bail: options.bail || false,
      randomize: options.randomize || false
    },
    coverage: {
      enabled: Boolean(coverage),
      threshold: Number(coverageThreshold),
      reporters: options.coverageReporters || ['text', 'lcov'],
      directories: options.coverageDirectories || ['src'],
      exclude: options.coverageExclude || ['test/**', 'node_modules/**']
    },
    filePatterns: {
      testMatch: Array.isArray(testMatch) ? testMatch : [String(testMatch)],
      testIgnore: Array.isArray(testIgnore) ? testIgnore : [String(testIgnore)]
    },
    setup: {
      files: Array.isArray(setupFiles) ? setupFiles : [String(setupFiles)],
      teardownFiles: Array.isArray(teardownFiles) ? teardownFiles : [String(teardownFiles)]
    },
    reporters: Array.isArray(reporters) ? reporters : [String(reporters)],
    environment: String(environment),
    globals: Object(globals),
    verbose: Boolean(verbose),
    watch: options.watch || false,
    cache: options.cache !== false
  };
}
/**
 * Create performance metrics configuration
 * @param {Object} options - Performance metrics options
 * @returns {Object} Performance metrics configuration
 */
function createPerformanceMetrics(options = {}) {
  const {
    enabled = true,
    interval = 60000, // 1 minute
    retentionPeriod = 24 * 60 * 60 * 1000, // 24 hours
    metrics = ['cpu', 'memory', 'responseTime', 'throughput'],
    alerts = {},
    aggregation = 'average',
    samplingRate = 1.0
  } = options;
  if (interval <= 0) {
    throw new Error('Metrics interval must be positive');
  }
  if (samplingRate < 0 || samplingRate > 1) {
    throw new Error('Sampling rate must be between 0 and 1');
  }
  return {
    enabled: Boolean(enabled),
    collection: {
      interval: Number(interval),
      retentionPeriod: Number(retentionPeriod),
      metrics: Array.isArray(metrics) ? metrics : [String(metrics)],
      samplingRate: Number(samplingRate)
    },
    aggregation: {
      method: String(aggregation), // average, median, min, max, sum
      windowSize: options.aggregationWindowSize || 100
    },
    alerts: Object(alerts),
    storage: {
      type: options.storageType || 'memory', // memory, file, database
      location: options.storageLocation || './metrics',
      compression: options.compressionEnabled || false
    },
    reporting: {
      enabled: options.reportingEnabled !== false,
      interval: options.reportingInterval || 5 * 60 * 1000, // 5 minutes
      destinations: options.reportDestinations || ['console']
    }
  };
}
/**
 * Create processing capabilities configuration
 * @param {Object} options - Processing capabilities options
 * @returns {Object} Processing capabilities configuration
 */
function createProcessingCapabilities(options = {}) {
  const {
    maxConcurrentTasks = 10,
    taskTimeout = 30000, // 30 seconds
    queueSize = 1000,
    retryAttempts = 3,
    retryDelay = 1000,
    deadLetterQueue = true,
    priorityLevels = ['low', 'normal', 'high', 'critical'],
    loadBalancing = 'round-robin'
  } = options;
  if (maxConcurrentTasks <= 0) {
    throw new Error('Max concurrent tasks must be positive');
  }
  if (taskTimeout <= 0) {
    throw new Error('Task timeout must be positive');
  }
  if (queueSize <= 0) {
    throw new Error('Queue size must be positive');
  }
  return {
    concurrency: {
      maxTasks: Number(maxConcurrentTasks),
      taskTimeout: Number(taskTimeout),
      queueSize: Number(queueSize)
    },
    retry: {
      maxAttempts: Number(retryAttempts),
      delay: Number(retryDelay),
      backoffMultiplier: options.retryBackoffMultiplier || 2,
      maxDelay: options.retryMaxDelay || 60000
    },
    errorHandling: {
      deadLetterQueue: Boolean(deadLetterQueue),
      maxRetriesBeforeDLQ: options.maxRetriesBeforeDLQ || retryAttempts,
      dlqSize: options.dlqSize || 100
    },
    priorities: {
      levels: Array.isArray(priorityLevels) ? priorityLevels : [String(priorityLevels)],
      defaultLevel: options.defaultPriority || 'normal',
      weightings: options.priorityWeightings || {}
    },
    loadBalancing: {
      strategy: String(loadBalancing), // round-robin, least-connections, weighted
      healthCheck: options.loadBalancingHealthCheck || true,
      healthCheckInterval: options.healthCheckInterval || 30000
    }
  };
}
module.exports = {
  buildFeatureConfig,
  buildSecurityConfig,
  buildValidationConfig,
  buildTestRunnerConfig,
  createPerformanceMetrics,
  createProcessingCapabilities
};

@scrooge/exec-helper-wrapper
Purpose: Higher-order function decorator for standardizing service method execution with error handling and logging. Explanation:
This module provides a decorator/wrapper for service methods that standardizes execution patterns, error handling, and logging across service layers. It solves the problem of repetitive try-catch blocks and inconsistent error handling in service methods by providing a standardized wrapper that handles execution, logging, and error transformation. This would be reused across any service layer architecture where consistent error handling and logging is required, particularly in microservices and enterprise applications.

The module accepts functions and configuration options, returning wrapped functions with standardized execution patterns. It handles edge cases like async vs sync functions, error transformation, and provides flexible configuration for different service patterns.

/**
 * Exec Helper Wrapper Decorator
 * 
 * Provides higher-order function wrapping for service methods
 * with standardized error handling and logging
 */
const { qerrors } = require('../offlineMode/index.js');
/**
 * Wrap a function with exec helper functionality
 * @param {Function} fn - Function to wrap
 * @param {Object} options - Wrapper options
 * @returns {Function} Wrapped function
 */
function execHelperWrapper(fn, options = {}) {
  const {
    context = 'Unknown',
    logExecution = true,
    logErrors = true,
    logPerformance = false,
    errorTransform = null,
    timeoutMs = null,
    retryCount = 0,
    retryDelay = 1000,
    validateInput = null,
    validateOutput = null
  } = options;
  if (typeof fn !== 'function') {
    throw new Error('Function to wrap must be a valid function');
  }
  const functionName = fn.name || 'anonymous';
  const wrapperContext = `${context}:${functionName}`;
  return async (...args) => {
    const startTime = logPerformance ? Date.now() : null;
    try {
      // Log execution start
      if (logExecution) {
        console.log(`[ExecHelper] Starting ${wrapperContext}`);
      }
      // Validate input if validator provided
      if (validateInput && typeof validateInput === 'function') {
        const validationResult = validateInput(...args);
        if (validationResult !== true) {
          throw new Error(`Input validation failed: ${validationResult}`);
        }
      }
      // Execute with timeout if specified
      let result;
      if (timeoutMs) {
        result = await executeWithTimeout(fn, args, timeoutMs);
      } else {
        result = await executeWithRetry(fn, args, retryCount, retryDelay);
      }
      // Validate output if validator provided
      if (validateOutput && typeof validateOutput === 'function') {
        const validationResult = validateOutput(result);
        if (validationResult !== true) {
          throw new Error(`Output validation failed: ${validationResult}`);
        }
      }
      // Log success and performance
      if (logExecution) {
        console.log(`[ExecHelper] Completed ${wrapperContext}`);
      }
      if (logPerformance && startTime) {
        const executionTime = Date.now() - startTime;
        console.log(`[ExecHelper] Performance ${wrapperContext}: ${executionTime}ms`);
      }
      return result;
    } catch (error) {
      // Transform error if transform function provided
      let finalError = error;
      if (errorTransform && typeof errorTransform === 'function') {
        try {
          finalError = errorTransform(error);
        } catch (transformError) {
          console.error(`[ExecHelper] Error transformation failed:`, transformError);
          finalError = error; // Use original error if transform fails
        }
      }
      // Log error with context
      if (logErrors) {
        qerrors(finalError, wrapperContext, {
          args: logErrors ? args : undefined, // Only log args if error logging is enabled
          executionTime: startTime ? Date.now() - startTime : undefined
        });
      }
      throw finalError;
    }
  };
}
/**
 * Execute function with timeout
 * @param {Function} fn - Function to execute
 * @param {Array} args - Function arguments
 * @param {number} timeoutMs - Timeout in milliseconds
 * @returns {Promise} Execution promise
 */
async function executeWithTimeout(fn, args, timeoutMs) {
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error(`Function execution timed out after ${timeoutMs}ms`));
    }, timeoutMs);
    Promise.resolve(fn(...args))
      .then(result => {
        clearTimeout(timeout);
        resolve(result);
      })
      .catch(error => {
        clearTimeout(timeout);
        reject(error);
      });
  });
}
/**
 * Execute function with retry logic
 * @param {Function} fn - Function to execute
 * @param {Array} args - Function arguments
 * @param {number} retryCount - Number of retries
 * @param {number} retryDelay - Delay between retries in milliseconds
 * @returns {Promise} Execution promise
 */
async function executeWithRetry(fn, args, retryCount, retryDelay) {
  let lastError;
  for (let attempt = 0; attempt <= retryCount; attempt++) {
    try {
      return await fn(...args);
    } catch (error) {
      lastError = error;
      // Don't retry on certain error types
      if (error.statusCode === 400 || error.statusCode === 401 || error.statusCode === 403) {
        throw error;
      }
      // If this is the last attempt, throw the error
      if (attempt === retryCount) {
        throw error;
      }
      // Wait before retry
      if (retryDelay > 0) {
        await new Promise(resolve => setTimeout(resolve, retryDelay));
      }
    }
  }
  throw lastError;
}
/**
 * Decorator for class methods
 * @param {Object} options - Wrapper options
 * @returns {Function} Method decorator
 */
function createMethodDecorator(options = {}) {
  return function(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = execHelperWrapper(originalMethod, {
      ...options,
      context: options.context || target.constructor.name
    });
    
    return descriptor;
  };
}
/**
 * Wrap all methods in a class with exec helper
 * @param {Object} target - Class prototype or constructor
 * @param {Object} options - Wrapper options
 * @returns {Object} Modified class with wrapped methods
 */
function wrapClassMethods(target, options = {}) {
  const prototype = target.prototype || target;
  const propertyNames = Object.getOwnPropertyNames(prototype);
  propertyNames.forEach(propertyName => {
    const descriptor = Object.getOwnPropertyDescriptor(prototype, propertyName);
    
    if (descriptor && typeof descriptor.value === 'function' && propertyName !== 'constructor') {
      const originalMethod = descriptor.value;
      descriptor.value = execHelperWrapper(originalMethod, {
        ...options,
        context: options.context || target.name || 'Class'
      });
      
      Object.defineProperty(prototype, propertyName, descriptor);
    }
  });
  return target;
}
/**
 * Create an exec helper instance with default options
 * @param {Object} defaultOptions - Default options for all wrappers
 * @returns {Object} Exec helper instance
 */
function createExecHelper(defaultOptions = {}) {
  return {
    wrap: (fn, options = {}) => execHelperWrapper(fn, { ...defaultOptions, ...options }),
    decorator: (options = {}) => createMethodDecorator({ ...defaultOptions, ...options }),
    wrapClass: (target, options = {}) => wrapClassMethods(target, { ...defaultOptions, ...options })
  };
}
module.exports = {
  execHelperWrapper,
  createMethodDecorator,
  wrapClassMethods,
  createExecHelper
};